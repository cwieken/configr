{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Configr","text":"<p>A flexible, type-safe configuration management library for Python.</p>"},{"location":"#_1","title":"Home","text":"<p>Note</p> <p>The API documentation and usage examples in this project were initially generated with the assistance of Claude, an AI assistant. All content has been reviewed and edited by the project maintainers to ensure accuracy and clarity.</p>"},{"location":"#overview","title":"Overview","text":"<p>Configr simplifies configuration management by leveraging Python's dataclasses and type hints to provide a robust, type-safe approach to application configuration.  It seamlessly converts configuration files to strongly-typed Python classes, making configuration both safer and easier to work with.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Type Safety: Leverage Python's type hints for configuration validation</li> <li>Dataclass Integration: Seamlessly map configuration files to Python dataclasses</li> <li>Multiple Format Support: Load configuration from JSON and YAML</li> <li>Extendable: Easily add support for custom configuration formats, such as TOML or XML</li> <li>Simple API: Convenient decorator-based approach for defining configuration classes</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from configr import config_class, ConfigBase\n\n@config_class(file_name=\"database.json\")\nclass DatabaseConfig:\n    host: str\n    port: int\n    username: str\n    password: str\n    database: str\n\n# Load configuration\ndb_config = ConfigBase.load(DatabaseConfig)\n\n# Use configuration\nprint(f\"Connecting to {db_config.database} at {db_config.host}:{db_config.port}\")\n</code></pre> <p>With a JSON file at <code>_config/database.json</code>:</p> <pre><code>{\n  \"host\": \"localhost\",\n  \"username\": \"admin\",\n  \"password\": \"secure_password\",\n  \"database\": \"my_app\"\n}\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install Configr using pip:</p> <pre><code>pip install configr\n</code></pre> <p>For YAML support, install with the YAML extra:</p> <pre><code>pip install configr[yaml]\n</code></pre>"},{"location":"#why-choose-configr","title":"Why Choose Configr?","text":"<ul> <li>Developer Experience: Get IDE autocompletion and type checking for configuration</li> <li>Type Safety: Catch configuration errors early with type validation</li> <li>Clean Codebase: Separate configuration concerns from application logic</li> <li>Flexibility: Support for different file formats with a consistent API</li> <li>Simplicity: Define your configuration structure once as a dataclass</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Read the Getting Started guide</li> <li>Check out the Examples</li> <li>Browse the API Reference</li> </ul>"},{"location":"contributing/","title":"Contributing to Configr","text":"<p>First off, thank you for considering contributing to Configr! It's people like you that make Configr better for everyone.</p> <p>This document provides guidelines and steps for contributing to this project.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you are expected to uphold our principles of openness, respect, and inclusivity. We welcome contributions from everyone regardless of gender, race, ethnicity, or any other factor. Contributions are evaluated solely on their merit.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Git</li> </ul>"},{"location":"contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:    <pre><code>git clone https://github.com/YOUR-USERNAME/configr.git\ncd configr\n</code></pre></li> <li>Install development dependencies:    <pre><code>pip install -r requirements-dev.txt\n</code></pre></li> </ol>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch:    <pre><code>git checkout -b my-branch-name\n</code></pre></li> </ol> <p>Choose a descriptive branch name that reflects the changes you're making.</p> <ol> <li>Make your changes</li> <li> <p>Test your changes:    <pre><code>pytest\n</code></pre>    Ensure all existing tests pass. If you've modified functionality, add or update tests accordingly.</p> </li> <li> <p>Follow PEP 8 coding standards</p> </li> <li>While no specific linter is required, your code should adhere to PEP 8 guidelines.</li> </ol>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":"<ol> <li> <p>Push your changes to your fork:    <pre><code>git push origin my-branch-name\n</code></pre></p> </li> <li> <p>Submit a pull request on GitHub</p> </li> <li>Provide a clear description of the problem and solution</li> <li>Include any relevant issue numbers by using keywords like \"Fixes #123\" or \"Resolves #123\"</li> <li>Explain your approach and the reasoning behind your changes</li> </ol>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update documentation if your changes modify the behavior or structure of the code</li> <li>Ensure your code passes all tests</li> <li>Your pull request will be reviewed by maintainers</li> <li>Address any feedback or requested changes</li> <li>Once approved, your pull request will be merged</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>If your contribution changes how users interact with the project or modifies its functionality, please update the relevant documentation. Pull requests that change functionality without updating documentation may be rejected.</p>"},{"location":"contributing/#communication","title":"Communication","text":"<ul> <li>For bug reports, feature requests, or discussions, please open an issue on GitHub</li> <li>For questions or clarifications about contributing, open a discussion on GitHub</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors will be acknowledged in our README.md file. Significant contributors may be added to a CONTRIBUTORS.md file in the future. All contributions remain visible and attributed in the Git history.</p>"},{"location":"contributing/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Pull Request Documentation</li> <li>PEP 8 Style Guide</li> </ul> <p>Thank you for contributing to Configr!</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides practical examples of using Configr in different scenarios. Each example demonstrates key features and patterns to help you make the most of the library in your projects.</p>"},{"location":"examples/#basic-configuration","title":"Basic Configuration","text":""},{"location":"examples/#simple-application-configuration","title":"Simple Application Configuration","text":"<p>This example shows a basic application configuration setup.</p> <pre><code># app_config.py\nfrom configr import config_class, ConfigBase\n\n@config_class(file_name=\"app_settings.json\")\nclass AppConfig:\n    app_name: str\n    version: str\n    debug: bool = False\n    log_level: str = \"INFO\"\n    max_connections: int = 100\n\n# Load the configuration\napp_config = ConfigBase.load(AppConfig)\n\n# Use the configuration\nprint(f\"Starting {app_config.app_name} v{app_config.version}\")\nprint(f\"Debug mode: {app_config.debug}\")\nprint(f\"Log level: {app_config.log_level}\")\n</code></pre> <p>Configuration file (<code>_config/app_settings.json</code>): <pre><code>{\n  \"app_name\": \"MyApp\",\n  \"version\": \"1.0.0\",\n  \"debug\": true,\n  \"log_level\": \"DEBUG\"\n}\n</code></pre></p>"},{"location":"examples/#nested-configuration","title":"Nested Configuration","text":""},{"location":"examples/#database-and-logging-configuration","title":"Database and Logging Configuration","text":"<p>This example demonstrates nested configuration structures.</p> <pre><code># config.py\nfrom configr import config_class, ConfigBase\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass DatabaseConfig:\n    username: str\n    password: str\n    database: str\n    host: str = \"localhost\"\n    port: int = 5432\n    ssl_mode: str = \"prefer\"\n\n    def get_connection_string(self):\n        \"\"\"Generate a database connection string.\"\"\"\n        return f\"postgresql://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}?sslmode={self.ssl_mode}\"\n\n@dataclass\nclass LoggingConfig:\n    level: str = \"INFO\"\n    file: str = None\n    format: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    max_size: int = 10485760  # 10MB\n    backup_count: int = 5\n\n@config_class(file_name=\"server_config.json\")\nclass ServerConfig:\n    name: str\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    workers: int = 4\n    database: DatabaseConfig = field(default_factory=DatabaseConfig)\n    logging: LoggingConfig = None\n\n    def __post_init__(self):\n        # Validation\n        if self.port &lt; 1024 or self.port &gt; 65535:\n            raise ValueError(f\"Invalid port: {self.port}\")\n        if self.workers &lt; 1:\n            raise ValueError(f\"Workers must be at least 1, got {self.workers}\")\n\n# main.py\nfrom config import ServerConfig, ConfigBase\n\nserver_config = ConfigBase.load(ServerConfig)\n\n# Access nested configuration\ndb_conn_string = server_config.database.get_connection_string()\n\n# If server_config.logging is None, it will create an instance of LoggingConfig \n# with default values, so log level is set to INFO in that case.\nlog_level = server_config.logging.level\n\nprint(f\"Server: {server_config.name} running on {server_config.host}:{server_config.port}\")\nprint(f\"Database connection: {db_conn_string}\")\nprint(f\"Log level: {log_level}\")\n</code></pre> <p>Configuration file (<code>_config/server_config.json</code>): <pre><code>{\n  \"name\": \"ProductionServer\",\n  \"port\": 8080,\n  \"workers\": 8,\n  \"database\": {\n    \"host\": \"db.example.com\",\n    \"username\": \"admin\",\n    \"password\": \"secure_password\",\n    \"database\": \"production_db\",\n    \"ssl_mode\": \"require\"\n  },\n  \"logging\": {\n    \"level\": \"WARNING\",\n    \"file\": \"/var/log/myapp.log\",\n    \"backup_count\": 10\n  }\n}\n</code></pre></p>"},{"location":"examples/#multiple-configuration-files","title":"Multiple Configuration Files","text":""},{"location":"examples/#separate-configs-for-different-components","title":"Separate Configs for different Components","text":"<p>This example shows how to work with multiple configuration files for different components of your application.</p> <pre><code># configs.py\nfrom configr import config_class, ConfigBase\n\n@config_class(file_name=\"database.json\")\nclass DatabaseConfig:\n    username: str\n    password: str\n    database: str\n    host: str = 'localhost'\n    port: int = 5432\n    max_connections: int = 100\n\n@config_class(file_name=\"redis.json\")\nclass RedisConfig:\n    host: str = \"localhost\"\n    port: int = 6379\n    db: int = 0\n    password: str = None\n    socket_timeout: int = 5\n\n@config_class(file_name=\"app.json\")\nclass AppConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    secret_key: str\n    allowed_hosts: list[str] = None\n\n# Access specific configurations\ndb_config = ConfigBase.load(DatabaseConfig)\nredis_config = ConfigBase.load(RedisConfig)\napp_config = ConfigBase.load(AppConfig)\n\nprint(f\"Database: {db_config.host}:{db_config.port}/{db_config.database}\")\nprint(f\"Redis: {redis_config.host}:{redis_config.port}\")\nprint(f\"App debug mode: {app_config.debug}\")\n</code></pre> <p>Configuration files:</p> <p><code>_config/database.json</code>: <pre><code>{\n  \"host\": \"db.example.com\",\n  \"username\": \"admin\",\n  \"password\": \"secure_password\",\n  \"database\": \"myapp_db\",\n  \"max_connections\": 50\n}\n</code></pre></p> <p><code>_config/redis.json</code>: <pre><code>{\n  \"host\": \"redis.example.com\",\n  \"password\": \"redis_password\"\n}\n</code></pre></p> <p><code>_config/app.json</code>: <pre><code>{\n  \"debug\": false,\n  \"log_level\": \"WARNING\",\n  \"secret_key\": \"very-secret-key-123\",\n  \"allowed_hosts\": [\"example.com\", \"www.example.com\"]\n}\n</code></pre></p>"},{"location":"examples/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"examples/#dynamic-configuration-based-on-environment","title":"Dynamic Configuration Based on Environment","text":"<p>This example demonstrates loading different configurations based on the environment.</p> <pre><code># config.py\nimport os\nfrom configr import config_class, ConfigBase\n\n# Determine environment\nENV = os.environ.get(\"APP_ENV\", \"development\")\n\n@config_class(file_name=f\"app.{ENV}.json\")\nclass AppConfig:\n    debug: bool = ENV != \"production\"\n    log_level: str = \"DEBUG\" if ENV != \"production\" else \"INFO\"\n    database_url: str\n    redis_url: str = None\n    secret_key: str\n    allowed_hosts: list[str] = None\n\n\n# app.py\nfrom config import get_config, ENV\n\nconfig = ConfigBase.load(AppConfig)\nprint(f\"Running in {ENV} environment\")\nprint(f\"Debug mode: {config.debug}\")\nprint(f\"Log level: {config.log_level}\")\nprint(f\"Database URL: {config.database_url}\")\n</code></pre> <p>Configuration files:</p> <p><code>_config/app.development.json</code>: <pre><code>{\n  \"debug\": true,\n  \"log_level\": \"DEBUG\",\n  \"database_url\": \"postgresql://dev:dev@localhost/dev_db\",\n  \"secret_key\": \"dev-secret-key\",\n  \"allowed_hosts\": [\"localhost\", \"127.0.0.1\"]\n}\n</code></pre></p> <p><code>_config/app.production.json</code>: <pre><code>{\n  \"debug\": false,\n  \"log_level\": \"WARNING\",\n  \"database_url\": \"postgresql://user:pass@db.example.com/prod_db\",\n  \"redis_url\": \"redis://redis.example.com:6379/0\",\n  \"secret_key\": \"production-secret-key-very-secure\",\n  \"allowed_hosts\": [\"example.com\", \"www.example.com\", \"api.example.com\"]\n}\n</code></pre></p>"},{"location":"examples/#list-of-dataclasses","title":"List of Dataclasses","text":""},{"location":"examples/#service-configuration-with-multiple-endpoints","title":"Service Configuration with Multiple Endpoints","text":"<p>This example shows how to configure a list of service endpoints.</p> <pre><code># services_config.py\nfrom configr import config_class, ConfigBase\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass ServiceEndpoint:\n    name: str\n    url: str\n    timeout: int = 30\n    retries: int = 3\n    api_key: str = None\n\n@config_class(file_name=\"services.json\")\nclass ServicesConfig:\n    base_timeout: int = 60\n    default_retries: int = 5\n    endpoints: List[ServiceEndpoint]\n\n    def get_endpoint(self, name):\n        \"\"\"Find an endpoint by name.\"\"\"\n        for endpoint in self.endpoints:\n            if endpoint.name == name:\n                return endpoint\n        return None\n\n# Load the configuration\nservices_config = ConfigBase.load(ServicesConfig)\n\n# Get a specific endpoint\nauth_service = services_config.get_endpoint(\"authentication\")\nif auth_service:\n    print(f\"Auth service URL: {auth_service.url}\")\n    print(f\"Auth service timeout: {auth_service.timeout}s\")\n\n# Iterate through all endpoints\nprint(\"Available services:\")\nfor endpoint in services_config.endpoints:\n    print(f\"- {endpoint.name}: {endpoint.url}\")\n</code></pre> <p>Configuration file (<code>_config/services.json</code>): <pre><code>{\n  \"base_timeout\": 30,\n  \"endpoints\": [\n    {\n      \"name\": \"authentication\",\n      \"url\": \"https://auth.example.com/api\",\n      \"timeout\": 10,\n      \"api_key\": \"auth-api-key-123\"\n    },\n    {\n      \"name\": \"storage\",\n      \"url\": \"https://storage.example.com/api\",\n      \"timeout\": 60,\n      \"retries\": 5\n    },\n    {\n      \"name\": \"analytics\",\n      \"url\": \"https://analytics.example.com/api\",\n      \"api_key\": \"analytics-api-key-456\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"examples/#custom-loaders","title":"Custom Loaders","text":""},{"location":"examples/#toml-configuration-format","title":"TOML Configuration Format","text":"<p>This example demonstrates creating and using a custom loader for TOML files.</p> <pre><code># toml_loader.py\nfrom pathlib import Path\nfrom typing import Dict, Any\nfrom configr import ConfigLoader, ConfigBase\n\nclass TOMLConfigLoader(ConfigLoader):\n    \"\"\"Loader for TOML configuration files.\"\"\"\n\n    def load(self, path: Path) -&gt; Dict[str, Any]:\n        \"\"\"Load TOML configuration from the specified path.\"\"\"\n        try:\n            import toml\n        except ImportError:\n            raise ImportError(\"The 'toml' package is required for TOML support. Install with 'pip install toml'.\")\n\n        with open(path, 'r') as f:\n            return toml.load(f)\n\n\n# config.py\nfrom configr import config_class, ConfigBase\nfrom toml_loader import TOMLConfigLoader\n\n# Register the TOML loader\nConfigBase.add_loader('.toml', TOMLConfigLoader)\n\n@config_class(file_name=\"app_config.toml\")\nclass AppConfig:\n    name: str\n    version: str\n    authors: list[str]\n    debug: bool = False\n\n    class Dependencies:\n        python: str\n        requests: str\n\n    dependencies: Dependencies\n\n# Load TOML configuration\napp_config = ConfigBase.load(AppConfig)\nprint(f\"App: {app_config.name} v{app_config.version}\")\nprint(f\"Authors: {', '.join(app_config.authors)}\")\nprint(f\"Python version: {app_config.dependencies.python}\")\n</code></pre> <p>Configuration file (<code>_config/app_config.toml</code>): <pre><code>name = \"MyTOMLApp\"\nversion = \"0.1.0\"\nauthors = [\"Jane Doe\", \"John Smith\"]\ndebug = true\n\n[dependencies]\npython = \"&gt;=3.9\"\nrequests = \"^2.28.0\"\n</code></pre></p>"},{"location":"examples/#error-handling","title":"Error Handling","text":""},{"location":"examples/#robust-configuration-loading","title":"Robust Configuration Loading","text":"<p>This example shows how to handle various configuration errors gracefully.</p> <pre><code># config.py\nfrom configr import config_class, ConfigBase, ConfigFileNotFoundError, ConfigValidationError\n\n@config_class(file_name=\"app_settings.json\")\nclass AppSettings:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    port: int = 8000\n\n    def __post_init__(self):\n        valid_log_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n        if self.log_level not in valid_log_levels:\n            raise ValueError(f\"Invalid log level: {self.log_level}. Must be one of {valid_log_levels}\")\n\n        if self.port &lt; 1024 or self.port &gt; 65535:\n            raise ValueError(f\"Invalid port: {self.port}. Must be between 1024 and 65535\")\n\ndef load_settings():\n    \"\"\"Load settings with robust error handling.\"\"\"\n    try:\n        return ConfigBase.load(AppSettings)\n    except ConfigFileNotFoundError as e:\n        print(f\"Configuration file not found: {e}\")\n        print(\"Using default settings\")\n        return AppSettings()\n    except ConfigValidationError as e:\n        print(f\"Configuration validation failed: {e}\")\n        print(\"Please check your configuration file format and types\")\n        raise \n    except ValueError as e:\n        print(f\"Invalid configuration value: {e}\")\n        print(\"Please check your configuration settings\")\n        raise \n    except Exception as e:\n        print(f\"Unexpected error loading configuration: {e}\")\n        print(\"Using default settings as fallback\")\n        return AppSettings()\n\n# app.py\nfrom config import load_settings\n\n# Load settings with error handling\nsettings = load_settings()\n\n# Use the settings\nprint(f\"Starting server on port {settings.port}\")\nprint(f\"Debug mode: {settings.debug}\")\nprint(f\"Log level: {settings.log_level}\")\n</code></pre>"},{"location":"examples/#web-application-example","title":"Web Application Example","text":""},{"location":"examples/#flask-web-app-configuration","title":"Flask Web App Configuration","text":"<p>This example demonstrates using Configr with a Flask web application.</p> <pre><code># config.py\nimport os\nfrom configr import config_class, ConfigBase, ConfigFileNotFoundError\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Any\n\n# Determine environment\nENV = os.environ.get(\"FLASK_ENV\", \"development\")\n\n@dataclass\nclass DatabaseConfig:\n    url: str\n    pool_size: int = 10\n    pool_recycle: int = 3600\n    pool_timeout: int = 30\n\n@dataclass\nclass CacheConfig:\n    type: str = \"redis\"\n    url: str = \"redis://localhost:6379/0\"\n    timeout: int = 300\n\n@config_class(file_name=f\"flask_app.{ENV}.json\")\nclass FlaskConfig:\n    # Flask settings\n    secret_key: str\n    debug: bool = ENV != \"production\"\n    testing: bool = ENV == \"testing\"\n    host: str = \"127.0.0.1\"\n    port: int = 5000\n\n    # Database settings\n    database: DatabaseConfig = None\n\n    # Cache settings\n    cache: CacheConfig = None\n\n    # CORS settings\n    cors_origins: List[str] = None\n\n    # Other settings\n    upload_folder: str = \"/tmp/uploads\"\n    max_content_length: int = 16 * 1024 * 1024  # 16 MB\n\n    # Custom app settings\n    app_name: str = \"Flask App\"\n    admin_emails: List[str] = None\n\n    def to_flask_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to a dictionary for Flask configuration.\"\"\"\n        # Extract top-level fields first\n        config_dict = {\n            \"SECRET_KEY\": self.secret_key,\n            \"DEBUG\": self.debug,\n            \"TESTING\": self.testing,\n            \"MAX_CONTENT_LENGTH\": self.max_content_length,\n            \"UPLOAD_FOLDER\": self.upload_folder,\n            \"APP_NAME\": self.app_name,\n            \"ADMIN_EMAILS\": self.admin_emails or []\n        }\n\n        # Add database settings\n        config_dict[\"SQLALCHEMY_DATABASE_URI\"] = self.database.url\n        config_dict[\"SQLALCHEMY_POOL_SIZE\"] = self.database.pool_size\n        config_dict[\"SQLALCHEMY_POOL_RECYCLE\"] = self.database.pool_recycle\n        config_dict[\"SQLALCHEMY_POOL_TIMEOUT\"] = self.database.pool_timeout\n        config_dict[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\n\n        # Add cache settings if present\n        if self.cache:\n            if self.cache.type == \"redis\":\n                config_dict[\"CACHE_TYPE\"] = \"RedisCache\"\n                config_dict[\"CACHE_REDIS_URL\"] = self.cache.url\n            else:\n                config_dict[\"CACHE_TYPE\"] = self.cache.type\n            config_dict[\"CACHE_DEFAULT_TIMEOUT\"] = self.cache.timeout\n\n        # Add CORS settings if present\n        if self.cors_origins:\n            config_dict[\"CORS_ORIGINS\"] = self.cors_origins\n\n        return config_dict\n\ndef get_flask_config():\n    \"\"\"Load and return Flask configuration.\"\"\"\n    try:\n        config = ConfigBase.load(FlaskConfig)\n        return config\n    except ConfigFileNotFoundError:\n        print(f\"Configuration file for {ENV} environment not found.\")\n        print(\"Using default configuration (this is not recommended for production)\")\n\n        # Default development config\n        if ENV == \"development\":\n            return FlaskConfig(\n                secret_key=\"dev-secret-key\",\n                database=DatabaseConfig(url=\"sqlite:///dev.db\"),\n                admin_emails=[\"admin@example.com\"]\n            )\n        # Default testing config\n        elif ENV == \"testing\":\n            return FlaskConfig(\n                secret_key=\"test-secret-key\",\n                testing=True,\n                database=DatabaseConfig(url=\"sqlite:///:memory:\"),\n            )\n        # For production, we should not use defaults\n        else:\n            raise\n\n# app.py\nfrom flask import Flask\nfrom config import get_flask_config\n\n# Load configuration\nconfig = get_flask_config()\n\n# Create Flask app\napp = Flask(__name__)\napp.config.update(config.to_flask_config())\n\n@app.route('/')\ndef index():\n    return f\"Welcome to {app.config['APP_NAME']}!\"\n\nif __name__ == '__main__':\n    app.run(host=config.host, port=config.port)\n</code></pre> <p>Configuration file (<code>_config/flask_app.development.json</code>): <pre><code>{\n  \"secret_key\": \"dev-secret-key-123\",\n  \"debug\": true,\n  \"port\": 5000,\n  \"database\": {\n    \"url\": \"sqlite:///dev.db\",\n    \"pool_size\": 5\n  },\n  \"cache\": {\n    \"type\": \"redis\",\n    \"url\": \"redis://localhost:6379/0\"\n  },\n  \"cors_origins\": [\"http://localhost:3000\", \"http://localhost:8080\"],\n  \"app_name\": \"My Flask App (Dev)\",\n  \"admin_emails\": [\"admin@example.com\", \"dev@example.com\"]\n}\n</code></pre></p>"},{"location":"examples/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/#configuration-with-immutable-dataclasses","title":"Configuration with Immutable Dataclasses","text":"<p>This example demonstrates using frozen dataclasses for immutable configuration.</p> <pre><code># config.py\nfrom configr import config_class, ConfigBase\nfrom dataclasses import dataclass, field, FrozenInstanceError\nfrom typing import Dict, List, Optional\n\n@dataclass(frozen=True)\nclass LoggingConfig:\n    level: str\n    file: Optional[str] = None\n    format: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n\n@dataclass(frozen=True)\nclass SecurityConfig:\n    secret_key: str\n    token_expiration: int = 3600  # seconds\n    allowed_hosts: List[str] = field(default_factory=list)\n    cors_origins: List[str] = field(default_factory=list)\n\n@config_class(file_name=\"immutable_config.json\")\n@dataclass(frozen=True)\nclass AppConfig:\n    name: str\n    version: str\n    debug: bool = False\n    logging: LoggingConfig = None\n    security: SecurityConfig = None\n    feature_flags: Dict[str, bool] = field(default_factory=dict)\n\n    def is_feature_enabled(self, feature_name: str) -&gt; bool:\n        \"\"\"Check if a feature flag is enabled.\"\"\"\n        return self.feature_flags.get(feature_name, False)\n\n# Load the immutable configuration\ntry:\n    config = ConfigBase.load(AppConfig)\n\n    # Using the configuration\n    print(f\"App: {config.name} v{config.version}\")\n    print(f\"Debug mode: {config.debug}\")\n\n    if config.logging:\n        print(f\"Log level: {config.logging.level}\")\n\n    if config.security:\n        print(f\"Token expiration: {config.security.token_expiration}s\")\n\n    # Check feature flags\n    print(\"Feature flags:\")\n    for feature, enabled in config.feature_flags.items():\n        print(f\"- {feature}: {'enabled' if enabled else 'disabled'}\")\n\n    # Attempt to modify (will raise an error)\n    try:\n        config.debug = True  # This will raise FrozenInstanceError\n    except FrozenInstanceError as e:\n        print(f\"Cannot modify immutable config: {e}\")\n\nexcept Exception as e:\n    print(f\"Error loading configuration: {e}\")\n</code></pre> <p>Configuration file (<code>_config/immutable_config.json</code>): <pre><code>{\n  \"name\": \"ImmutableApp\",\n  \"version\": \"1.2.0\",\n  \"debug\": false,\n  \"logging\": {\n    \"level\": \"INFO\",\n    \"file\": \"/var/log/app.log\"\n  },\n  \"security\": {\n    \"secret_key\": \"very-secret-key-123\",\n    \"token_expiration\": 7200,\n    \"allowed_hosts\": [\"example.com\", \"api.example.com\"],\n    \"cors_origins\": [\"https://app.example.com\"]\n  },\n  \"feature_flags\": {\n    \"new_ui\": true,\n    \"advanced_analytics\": false,\n    \"experimental_api\": false\n  }\n}\n</code></pre></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you quickly set up and start using Configr in your projects.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install Configr using pip:</p> <pre><code>pip install configr\n</code></pre> <p>If you want to use YAML configuration files, you'll need to install with the YAML extra:</p> <pre><code>pip install configr[yaml]\n</code></pre>"},{"location":"getting-started/#basic-setup","title":"Basic Setup","text":"<ol> <li>Create a configuration directory in your project (default is <code>_config/</code>)</li> <li>Define your configuration classes using the <code>@config_class</code> decorator</li> <li>Create corresponding configuration files (JSON or YAML)</li> <li>Load and use your configuration in your application</li> </ol>"},{"location":"getting-started/#configuration-directory","title":"Configuration Directory","text":"<p>By default, Configr looks for configuration files in a <code>_config/</code> directory at the root of your project. You can customize this by setting the <code>CONFIG_DIR</code> environment variable:</p> <pre><code>export CONFIG_DIR=path/to/your/config\n</code></pre> <p>Or programmatically:</p> <pre><code>import os\nos.environ[\"CONFIG_DIR\"] = \"path/to/your/config\"\n</code></pre>"},{"location":"getting-started/#defining-configuration-classes","title":"Defining Configuration Classes","text":"<p>Use the <code>@config_class</code> decorator to define your configuration structure:</p> <pre><code>from configr import config_class\n\n@config_class\nclass AppConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    max_connections: int = 100\n</code></pre> <p>By default, the library will look for a file named after the class in snake_case with a <code>.json</code> extension. For the <code>AppConfig</code> example above, it would look for <code>_config/app_config.json</code>.</p> <p>You can specify a custom file name:</p> <pre><code>@config_class(file_name=\"settings.yaml\")\nclass AppConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    max_connections: int = 100\n</code></pre>"},{"location":"getting-started/#loading-configuration","title":"Loading Configuration","text":"<p>Use the <code>ConfigBase.load()</code> method to load your configuration:</p> <pre><code>from configr import ConfigBase\n\n# Load your configuration\napp_config = ConfigBase.load(AppConfig)\n\n# Use the configuration\nif app_config.debug:\n    print(f\"Running in debug mode with log level {app_config.log_level}\")\n</code></pre>"},{"location":"getting-started/#configuration-file-formats","title":"Configuration File Formats","text":""},{"location":"getting-started/#json-example","title":"JSON Example","text":"<pre><code>{\n  \"debug\": true,\n  \"log_level\": \"DEBUG\",\n  \"max_connections\": 50\n}\n</code></pre>"},{"location":"getting-started/#yaml-example","title":"YAML Example","text":"<pre><code>debug: true\nlog_level: DEBUG\nmax_connections: 50\n</code></pre>"},{"location":"getting-started/#handling-missing-files","title":"Handling Missing Files","text":"<p>If a configuration file is missing, Configr will raise a <code>ConfigFileNotFoundError</code>. You can handle this gracefully:</p> <pre><code>from configr import ConfigBase, ConfigFileNotFoundError\n\ntry:\n    app_config = ConfigBase.load(AppConfig)\nexcept ConfigFileNotFoundError:\n    print(\"Configuration file not found, using defaults\")\n    app_config = AppConfig()\n</code></pre>"},{"location":"getting-started/#complete-example","title":"Complete Example","text":"<p>Here's a complete example of how to use Configr in a project:</p> <pre><code>import os\nfrom dataclasses import dataclass\nfrom configr import config_class, ConfigBase, ConfigFileNotFoundError\n\n# Define configuration classes\n@config_class(file_name=\"database.json\")\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n\n@config_class(file_name=\"app.json\")\nclass AppConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    max_connections: int = 100\n\n# Load configuration\ntry:\n    db_config = ConfigBase.load(DatabaseConfig)\n    app_config = ConfigBase.load(AppConfig)\n\n    # Use configuration\n    print(f\"Application running in {'debug' if app_config.debug else 'production'} mode\")\n    print(f\"Connecting to database {db_config.database} at {db_config.host}:{db_config.port}\")\n\nexcept ConfigFileNotFoundError as e:\n    print(f\"Configuration error: {e}\")\n    print(\"Using default configuration\")\n\n    # Fall back to defaults\n    db_config = DatabaseConfig(\n        username=\"default_user\",\n        password=\"default_password\",\n        database=\"default_db\"\n    )\n    app_config = AppConfig()\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics of Configr, you can explore more advanced topics:</p> <ul> <li>Configuration Classes: Learn more about defining and working with configuration classes</li> <li>Custom Loaders: Extend Configr with support for additional file formats</li> <li>Examples: See examples of Configr in action</li> </ul>"},{"location":"api/config-base/","title":"ConfigBase","text":"<p><code>ConfigBase</code> is the core class of the Configr library that handles loading configuration from files and converting it to dataclasses.</p>"},{"location":"api/config-base/#overview","title":"Overview","text":"<p><code>ConfigBase</code> provides a robust mechanism for loading and validating configuration data from various file formats (JSON, YAML, etc.) and converting it to strongly-typed Python dataclasses. It supports nested dataclass structures and provides a flexible, extensible interface for adding custom loaders.</p>"},{"location":"api/config-base/#class-definition","title":"Class Definition","text":"<pre><code>class ConfigBase(Generic[T]):\n    \"\"\"\n    Base class for configuration management.\n    Handles loading configuration from files and conversion to dataclasses.\n    \"\"\"\n</code></pre>"},{"location":"api/config-base/#class-variables","title":"Class Variables","text":"Variable Type Description <code>_config_dir</code> <code>ClassVar[str]</code> Directory path where configuration files are stored. Defaults to environment variable <code>CONFIG_DIR</code> or <code>_config</code> if not set. <code>_loaders</code> <code>ClassVar[dict[str, Type[ConfigLoader]]]</code> Dictionary mapping file extensions to their loader classes."},{"location":"api/config-base/#methods","title":"Methods","text":""},{"location":"api/config-base/#set_config_dir","title":"<code>set_config_dir</code>","text":"<p>Set the base configuration directory path.</p> <pre><code>@classmethod\ndef set_config_dir(cls, config_dir: str | Path) -&gt; None:\n</code></pre>"},{"location":"api/config-base/#parameters","title":"Parameters","text":"<ul> <li><code>config_dir</code>: A string or Path object representing the directory where configuration files are stored.</li> </ul>"},{"location":"api/config-base/#example","title":"Example","text":"<pre><code>from configr import ConfigBase\n\n# Set the configuration directory\nConfigBase.set_config_dir(\"configs\")\n\n# Or using a Path object\nfrom pathlib import Path\nConfigBase.set_config_dir(Path(\"configs\"))\n</code></pre>"},{"location":"api/config-base/#get_available_loaders","title":"<code>get_available_loaders</code>","text":"<p>Get the dictionary of available configuration loaders.</p> <pre><code>@classmethod\ndef get_available_loaders(cls) -&gt; dict[str, Type[ConfigLoader]]:\n</code></pre>"},{"location":"api/config-base/#returns","title":"Returns","text":"<p>A dictionary mapping file extensions to their respective loader classes.</p>"},{"location":"api/config-base/#example_1","title":"Example","text":"<pre><code>from configr import ConfigBase\n\n# Get all available loaders\nloaders = ConfigBase.get_available_loaders()\nprint(loaders)  # {'.json': JSONConfigLoader, '.yaml': YAMLConfigLoader, '.yml': YAMLConfigLoader}\n</code></pre>"},{"location":"api/config-base/#add_loader","title":"<code>add_loader</code>","text":"<p>Register a new configuration loader for a specific file extension.</p> <pre><code>@classmethod\ndef add_loader(cls, ext: str, loader: Type[ConfigLoader]) -&gt; None:\n</code></pre>"},{"location":"api/config-base/#parameters_1","title":"Parameters","text":"<ul> <li><code>ext</code>: The file extension (including the dot) to associate with the loader.</li> <li><code>loader</code>: The loader class that implements the <code>ConfigLoader</code> interface.</li> </ul>"},{"location":"api/config-base/#example_2","title":"Example","text":"<pre><code>from configr import ConfigBase, ConfigLoader\nfrom pathlib import Path\nimport toml\n\nclass TOMLConfigLoader(ConfigLoader):\n    def load(self, path: Path) -&gt; dict:\n        with open(path, 'r') as f:\n            return toml.load(f)\n\n# Register the TOML loader\nConfigBase.add_loader('.toml', TOMLConfigLoader)\n</code></pre>"},{"location":"api/config-base/#remove_loader","title":"<code>remove_loader</code>","text":"<p>Remove a configuration loader for a specific file extension.</p> <pre><code>@classmethod\ndef remove_loader(cls, ext: str) -&gt; None:\n</code></pre>"},{"location":"api/config-base/#parameters_2","title":"Parameters","text":"<ul> <li><code>ext</code>: The file extension to remove from the available loaders.</li> </ul>"},{"location":"api/config-base/#example_3","title":"Example","text":"<pre><code>from configr import ConfigBase\n\n# Remove the YAML loader\nConfigBase.remove_loader('.yaml')\n</code></pre>"},{"location":"api/config-base/#get_config_path","title":"<code>get_config_path</code>","text":"<p>Get the base configuration directory path.</p> <pre><code>@classmethod\ndef get_config_path(cls) -&gt; Path:\n</code></pre>"},{"location":"api/config-base/#returns_1","title":"Returns","text":"<p>A <code>Path</code> object representing the configuration directory.</p>"},{"location":"api/config-base/#example_4","title":"Example","text":"<pre><code>from configr import ConfigBase\n\n# Get the configuration directory path\nconfig_path = ConfigBase.get_config_path()\nprint(config_path)  # /path/to/_config\n</code></pre>"},{"location":"api/config-base/#load","title":"<code>load</code>","text":"<p>Load configuration from a file and convert it to the specified dataclass.</p> <pre><code>@classmethod\ndef load(cls, config_class: Type[T], config_data: dict | None = None) -&gt; T:\n</code></pre>"},{"location":"api/config-base/#parameters_3","title":"Parameters","text":"<ul> <li><code>config_class</code>: The dataclass to convert configuration to.</li> <li><code>config_data</code>: Optional dictionary containing configuration data. If not provided, it will be loaded from the file.</li> </ul>"},{"location":"api/config-base/#returns_2","title":"Returns","text":"<p>An instance of the specified dataclass with loaded configuration.</p>"},{"location":"api/config-base/#raises","title":"Raises","text":"<ul> <li><code>TypeError</code>: If <code>config_class</code> is not a dataclass.</li> <li><code>ConfigFileNotFoundError</code>: If the configuration file is not found.</li> <li><code>ConfigValidationError</code>: If the configuration fails validation.</li> </ul>"},{"location":"api/config-base/#example_5","title":"Example","text":"<pre><code>from configr import ConfigBase, config_class\n\n@config_class\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n\n# Load configuration from file\ndb_config = ConfigBase.load(DatabaseConfig)\n\n# Or with explicit configuration data\nconfig_data = {\n    \"host\": \"db.example.com\",\n    \"port\": 5432,\n    \"username\": \"admin\",\n    \"password\": \"secure_password\",\n    \"database\": \"my_app\"\n}\ndb_config = ConfigBase.load(DatabaseConfig, config_data)\n</code></pre>"},{"location":"api/config-base/#private-methods","title":"Private Methods","text":"<p>These methods are intended for internal use by the ConfigBase class:</p>"},{"location":"api/config-base/#_get_loader","title":"<code>_get_loader</code>","text":"<p>Determine the appropriate loader based on the file extension.</p> <pre><code>@classmethod\ndef _get_loader(cls, file_name) -&gt; ConfigLoader:\n</code></pre>"},{"location":"api/config-base/#parameters_4","title":"Parameters","text":"<ul> <li><code>file_name</code>: The name of the configuration file.</li> </ul>"},{"location":"api/config-base/#returns_3","title":"Returns","text":"<p>An instance of the appropriate <code>ConfigLoader</code> for the given file extension.</p>"},{"location":"api/config-base/#_get_config_file_path","title":"<code>_get_config_file_path</code>","text":"<p>Get the full path to the configuration file.</p> <pre><code>@classmethod\ndef _get_config_file_path(cls, file_name: str) -&gt; Path:\n</code></pre>"},{"location":"api/config-base/#parameters_5","title":"Parameters","text":"<ul> <li><code>file_name</code>: The name of the configuration file.</li> </ul>"},{"location":"api/config-base/#returns_4","title":"Returns","text":"<p>A <code>Path</code> object representing the full path to the configuration file.</p>"},{"location":"api/config-base/#_get_config_file_name","title":"<code>_get_config_file_name</code>","text":"<p>Get the file name from the configuration class.</p> <pre><code>@classmethod\ndef _get_config_file_name(cls, config_class: Type) -&gt; str:\n</code></pre>"},{"location":"api/config-base/#parameters_6","title":"Parameters","text":"<ul> <li><code>config_class</code>: The configuration class.</li> </ul>"},{"location":"api/config-base/#returns_5","title":"Returns","text":"<p>The file name associated with the configuration class.</p>"},{"location":"api/config-base/#implementation-details","title":"Implementation Details","text":"<p>The <code>ConfigBase</code> class:</p> <ol> <li>Determines the appropriate file to load based on the configuration class and extensions</li> <li>Uses the corresponding loader to parse the file into a dictionary</li> <li>Performs type validation using <code>FieldTypeChecker</code></li> <li>Handles nested dataclass structures recursively</li> <li>Creates and returns an instance of the specified dataclass with the loaded configuration data</li> </ol>"},{"location":"api/config-base/#example-usage","title":"Example Usage","text":"<pre><code>from configr import ConfigBase, config_class\n\n@config_class(file_name=\"database.json\")\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n\n@config_class(file_name=\"app.yaml\")\nclass AppConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    database: DatabaseConfig = None  # Nested configuration\n\n# Set custom configuration directory\nConfigBase.set_config_dir(\"my_configs\")\n\n# Load configurations\ndb_config = ConfigBase.load(DatabaseConfig)\napp_config = ConfigBase.load(AppConfig)\n\n# Use the loaded configuration\nprint(f\"Connecting to {db_config.database} at {db_config.host}:{db_config.port}\")\nprint(f\"Debug mode: {app_config.debug}, Log level: {app_config.log_level}\")\n</code></pre>"},{"location":"api/config-class/","title":"config_class","text":"<p><code>config_class</code> is a decorator used to mark classes as configuration classes in the Configr library. It simplifies the creation of configuration classes by automatically converting them to dataclasses and managing the association with configuration files.</p>"},{"location":"api/config-class/#overview","title":"Overview","text":"<p>The <code>config_class</code> decorator:</p> <ol> <li>Ensures the decorated class is a dataclass</li> <li>Associates a configuration file name with the class</li> <li>Provides a convention for naming configuration files based on the class name</li> </ol>"},{"location":"api/config-class/#function-signature","title":"Function Signature","text":"<pre><code>def config_class(cls=None, *, file_name: str = None):\n    \"\"\"\n    Decorator to mark a class as a configuration class.\n    This allows specifying a custom file name for the configuration.\n    \"\"\"\n</code></pre>"},{"location":"api/config-class/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>cls</code> <code>type</code> <code>None</code> The class to decorate <code>file_name</code> <code>str</code> <code>None</code> Optional name of the configuration file to associate with the class"},{"location":"api/config-class/#return-value","title":"Return Value","text":"<p>Returns the decorated class, which is:</p> <ul> <li>Converted to a dataclass if it's not already</li> <li>Enhanced with a <code>_config_file_name</code> class attribute</li> </ul>"},{"location":"api/config-class/#implementation-details","title":"Implementation Details","text":"<p>The decorator works in two ways:</p> <ol> <li> <p>Direct decoration: When used as <code>@config_class</code> (without parentheses), the class is passed directly as the first argument.</p> </li> <li> <p>Parameterized decoration: When used as <code>@config_class(file_name=...)</code>, a wrapper function is created that receives the class and applies the decoration.</p> </li> </ol> <p>The decorator:</p> <ul> <li>Converts the class to a dataclass if it isn't already one</li> <li>Sets the <code>_config_file_name</code> class attribute based on:<ul> <li>The explicitly provided <code>file_name</code> parameter</li> <li>The class name converted to snake_case (as a fallback)</li> </ul> </li> </ul>"},{"location":"api/config-class/#example-usage","title":"Example Usage","text":""},{"location":"api/config-class/#basic-example","title":"Basic Example","text":"<pre><code>from configr import config_class, ConfigBase\n\n@config_class\nclass DatabaseConfig:\n    host: str\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n\n# Load configuration\ndb_config = ConfigBase.load(DatabaseConfig)\n</code></pre>"},{"location":"api/config-class/#custom-file-name-example","title":"Custom File Name Example","text":"<pre><code>from configr import config_class, ConfigBase\n\n@config_class(file_name=\"db_config.yaml\")\nclass DatabaseConfig:\n    host: str\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n\n# Load configuration from db_config.yaml\ndb_config = ConfigBase.load(DatabaseConfig)\n</code></pre>"},{"location":"api/config-class/#with-nested-configuration","title":"With Nested Configuration","text":"<pre><code>from configr import config_class, ConfigBase\nfrom dataclasses import dataclass\n\n@dataclass\nclass LoggingConfig:\n    level: str = \"INFO\"\n    file: str = None\n    format: str = \"%(asctime)s - %(levelname)s - %(message)s\"\n\n@config_class(file_name=\"app_config.json\")\nclass AppConfig:\n    name: str\n    version: str\n    logging: LoggingConfig = None\n\n# Load configuration with nested structure\napp_config = ConfigBase.load(AppConfig)\n</code></pre>"},{"location":"api/config-class/#notes","title":"Notes","text":"<ul> <li>When no <code>file_name</code> is specified, the default is to use the class name converted to snake_case</li> <li>The extension (.json, .yaml, etc.) determines which loader will be used</li> <li>If the extension is omitted, Configr will try each registered loader in order until it finds a matching file</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>Configr defines custom exceptions to provide clear error handling and diagnostics when loading and validating configuration.</p>"},{"location":"api/exceptions/#exception-classes","title":"Exception Classes","text":""},{"location":"api/exceptions/#configfilenotfounderror","title":"ConfigFileNotFoundError","text":"<pre><code>class ConfigFileNotFoundError(FileNotFoundError):\n    \"\"\"Raised when a configuration file is not found.\"\"\"\n    pass\n</code></pre> <p>This exception is raised when Configr cannot find a configuration file for a given configuration class. It inherits from the built-in <code>FileNotFoundError</code> class.</p>"},{"location":"api/exceptions/#when-its-raised","title":"When It's Raised","text":"<ul> <li>When <code>ConfigBase.load()</code> is called and the specified configuration file does not exist</li> <li>When all potential file extensions are tried and no matching file is found</li> </ul>"},{"location":"api/exceptions/#example","title":"Example","text":"<pre><code>from configr import ConfigBase, ConfigFileNotFoundError\nfrom my_config import AppConfig\n\ntry:\n    config = ConfigBase.load(AppConfig)\nexcept ConfigFileNotFoundError as e:\n    print(f\"Configuration error: {e}\")\n    print(\"Using default configuration instead\")\n    config = AppConfig()  # Use default values defined in the class\n</code></pre>"},{"location":"api/exceptions/#configvalidationerror","title":"ConfigValidationError","text":"<pre><code>class ConfigValidationError(ValueError):\n    \"\"\"Raised when configuration validation fails.\"\"\"\n    pass\n</code></pre> <p>This exception is raised when the configuration data fails validation. It inherits from the built-in <code>ValueError</code> class.</p>"},{"location":"api/exceptions/#when-its-raised_1","title":"When It's Raised","text":"<ul> <li>When the types in the configuration file don't match the types defined in the configuration class</li> <li>When required fields are missing in the configuration data</li> </ul>"},{"location":"api/exceptions/#example_1","title":"Example","text":"<pre><code>from configr import ConfigBase, ConfigValidationError\nfrom my_config import ServerConfig\n\ntry:\n    config = ConfigBase.load(ServerConfig)\nexcept ConfigValidationError as e:\n    print(f\"Invalid configuration: {e}\")\n    print(\"Please check your configuration file and ensure all values are correct\")\n    raise  # Re-raise because this is a critical error\n</code></pre>"},{"location":"api/exceptions/#handling-exceptions","title":"Handling Exceptions","text":""},{"location":"api/exceptions/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Graceful Fallbacks: Handle <code>ConfigFileNotFoundError</code> by falling back to default values when possible</p> <pre><code>try:\n    db_config = ConfigBase.load(DatabaseConfig)\nexcept ConfigFileNotFoundError:\n    print(\"Database configuration not found, using defaults\")\n    db_config = DatabaseConfig(\n        host=\"localhost\",\n        username=\"default_user\",\n        password=\"default_password\",\n        database=\"default_db\"\n    )\n</code></pre> </li> <li> <p>Detailed Error Messages: Provide clear information when configuration validation fails</p> <pre><code>try:\n    app_config = ConfigBase.load(AppConfig)\nexcept ConfigValidationError as e:\n    print(f\"Configuration error in app_config.json: {e}\")\n    print(\"Please refer to the documentation for correct configuration format\")\n    sys.exit(1)  # Exit application if configuration is invalid\n</code></pre> </li> <li> <p>Combined Exception Handling: Handle multiple exception types appropriately</p> <pre><code>try:\n    config = ConfigBase.load(AppConfig)\nexcept ConfigFileNotFoundError:\n    print(\"Configuration file not found, using defaults\")\n    config = AppConfig()\nexcept ConfigValidationError as e:\n    print(f\"Configuration validation failed: {e}\")\n    raise  # Re-raise critical validation errors\nexcept Exception as e:\n    print(f\"Unexpected error loading configuration: {e}\")\n    raise\n</code></pre> </li> </ol>"},{"location":"api/exceptions/#custom-validation-exceptions","title":"Custom Validation Exceptions","text":"<p>You can raise <code>ConfigValidationError</code> in your own <code>__post_init__</code> methods to provide custom validation:</p> <pre><code>from configr import config_class, ConfigValidationError\n\n@config_class\nclass ServerConfig:\n    host: str\n    port: int\n    workers: int\n\n    def __post_init__(self):\n        if self.port &lt; 1024 or self.port &gt; 65535:\n            raise ConfigValidationError(f\"Invalid port: {self.port}. Must be between 1024 and 65535.\")\n        if self.workers &lt; 1:\n            raise ConfigValidationError(f\"Invalid workers: {self.workers}. Must be at least 1.\")\n</code></pre>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>The exception hierarchy in Configr is designed to be intuitive and integrate well with Python's built-in exceptions:</p> <pre><code>BaseException\n \u2514\u2500\u2500 Exception\n      \u251c\u2500\u2500 ValueError\n      \u2502    \u2514\u2500\u2500 ConfigValidationError\n      \u2514\u2500\u2500 OSError\n           \u2514\u2500\u2500 FileNotFoundError\n                \u2514\u2500\u2500 ConfigFileNotFoundError\n</code></pre> <p>This hierarchy allows you to catch exceptions at different levels depending on your needs:</p> <pre><code># Catch only Configr-specific file not found errors\nexcept ConfigFileNotFoundError as e:\n    # Handle missing configuration files\n\n# Catch any file not found errors\nexcept FileNotFoundError as e:\n    # Handle any missing files\n\n# Catch only Configr-specific validation errors\nexcept ConfigValidationError as e:\n    # Handle validation errors\n\n# Catch any value errors\nexcept ValueError as e:\n    # Handle any value errors\n\n# Catch any exceptions\nexcept Exception as e:\n    # Handle any exceptions\n</code></pre>"},{"location":"api/exceptions/#example-complete-error-handling","title":"Example: Complete Error Handling","text":"<p>Here's a complete example of robust error handling with Configr:</p> <pre><code>from configr import ConfigBase, config_class, ConfigFileNotFoundError, ConfigValidationError\n\n@config_class(file_name=\"database.json\")\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str = None\n    password: str = None\n    database: str = None\n\n    def __post_init__(self):\n        if self.port &lt; 1024 or self.port &gt; 65535:\n            raise ConfigValidationError(f\"Invalid port: {self.port}\")\n        if not self.username and not self.password:\n            # This is allowed, will use default authentication\n            pass\n        elif not self.username or not self.password:\n            # This is not allowed, must provide both or neither\n            raise ConfigValidationError(\"Both username and password must be provided\")\n\ndef load_database_config():\n    \"\"\"Load database configuration with robust error handling.\"\"\"\n    try:\n        return ConfigBase.load(DatabaseConfig)\n    except ConfigFileNotFoundError as e:\n        print(f\"Warning: {e}\")\n        print(\"Using default database configuration\")\n        return DatabaseConfig()\n    except ConfigValidationError as e:\n        print(f\"Error: Database configuration is invalid: {e}\")\n        print(\"Please check your database.json file\")\n        raise\n    except Exception as e:\n        print(f\"Unexpected error loading database configuration: {e}\")\n        raise\n\n# Usage\ndb_config = load_database_config()\nprint(f\"Connecting to {db_config.database} at {db_config.host}:{db_config.port}\")\n</code></pre>"},{"location":"api/field-type-checker/","title":"FieldTypeChecker","text":"<p>The <code>FieldTypeChecker</code> is a utility class in Configr that handles type checking for configuration fields. It ensures that loaded configuration values match their expected types according to the type annotations in your configuration classes.</p>"},{"location":"api/field-type-checker/#overview","title":"Overview","text":"<pre><code>class FieldTypeChecker:\n    \"\"\"\n    A utility class for checking if values match their expected types according to type annotations.\n\n    This class provides strict type checking for dataclass fields, supporting basic types,\n    generic types (List, Dict, Set, Tuple), Union types, and nested type structures.\n\n    It does not perform type conversion.\n    \"\"\"\n</code></pre> <p>The <code>FieldTypeChecker</code> provides comprehensive type validation, supporting:</p> <ol> <li>Basic Python types (str, int, float, bool, etc.)</li> <li>Generic collection types (List, Dict, Set, Tuple)</li> <li>Union and Optional types</li> <li>Nested dataclasses</li> <li>Complex nested structures (e.g., List[Dict[str, Any]])</li> </ol>"},{"location":"api/field-type-checker/#methods","title":"Methods","text":""},{"location":"api/field-type-checker/#check_types","title":"check_types","text":"<pre><code>@classmethod\ndef check_types(cls, fields: dict[str, Type], data: dict) -&gt; None:\n    \"\"\"\n    Check that all values in data match their expected types as defined in fields.\n\n    Args:\n        fields: A dictionary mapping field names to their type annotations.\n        data: A dictionary mapping field names to their values.\n\n    Raises:\n        TypeError: If any value doesn't match its expected type.\n    \"\"\"\n</code></pre>"},{"location":"api/field-type-checker/#parameters","title":"Parameters","text":"Parameter Type Description <code>fields</code> <code>dict[str, Type]</code> Dictionary mapping field names to their types <code>data</code> <code>dict</code> Dictionary mapping field names to their values"},{"location":"api/field-type-checker/#raises","title":"Raises","text":"<ul> <li><code>TypeError</code>: If any value doesn't match its expected type</li> </ul>"},{"location":"api/field-type-checker/#implementation-details","title":"Implementation Details","text":"<p>The <code>FieldTypeChecker</code> class includes several private helper methods:</p>"},{"location":"api/field-type-checker/#__check_basic_types","title":"__check_basic_types","text":"<pre><code>@classmethod\ndef __check_basic_types(cls, field_name: str, field_types: Type | tuple[Any, ...], value: any) -&gt; None:\n    \"\"\"\n    Check if a value matches a basic (non-generic) type annotation.\n\n    Args:\n        field_name: The name of the field being checked.\n        field_types: The expected type or tuple of types.\n        value: The value to check.\n\n    Raises:\n        TypeError: If the value doesn't match the expected type(s).\n    \"\"\"\n</code></pre> <p>This method checks if a value matches basic (non-generic) types.</p>"},{"location":"api/field-type-checker/#__check_generic_types","title":"__check_generic_types","text":"<pre><code>@classmethod\ndef __check_generic_types(cls, field_name: str, field_type: Type | tuple[Any, ...], value: any) -&gt; None:\n    \"\"\"\n    Check if a value matches a generic type annotation (List, Dict, Set, Tuple, Union, etc.).\n\n    Args:\n        field_name: The name of the field being checked.\n        field_type: The expected generic type.\n        value: The value to check.\n\n    Raises:\n        TypeError: If the value doesn't match the expected generic type structure.\n    \"\"\"\n</code></pre> <p>This method checks if a value matches generic types like List, Dict, Set, Tuple, Union, etc.</p>"},{"location":"api/field-type-checker/#__check_tuple_type","title":"__check_tuple_type","text":"<pre><code>@classmethod\ndef __check_tuple_type(cls, field_name: str, field_types: tuple[Any, ...], value: any) -&gt; None:\n    \"\"\"\n    Check if a value matches a tuple type annotation, including fixed-size and variable-size tuples.\n\n    Args:\n        field_name: The name of the field being checked.\n        field_types: The tuple of expected types for each element.\n        value: The tuple value to check.\n\n    Raises:\n        TypeError: If the tuple doesn't match the expected structure or element types.\n    \"\"\"\n</code></pre> <p>This method checks if a tuple value matches a tuple type annotation, handling both fixed-size and variable-size tuples.</p>"},{"location":"api/field-type-checker/#__check_dict_type","title":"__check_dict_type","text":"<pre><code>@classmethod\ndef __check_dict_type(cls, field_name: str, field_types: tuple[Any, ...], value: any) -&gt; None:\n    \"\"\"\n    Check if a value matches a dictionary type annotation, including checking key and value types.\n\n    Args:\n        field_name: The name of the field being checked.\n        field_types: A tuple containing (key_type, value_type).\n        value: The dictionary value to check.\n\n    Raises:\n        TypeError: If any key or value in the dictionary doesn't match its expected type.\n    \"\"\"\n</code></pre> <p>This method checks if a dictionary value matches a dictionary type annotation, validating both key and value types.</p>"},{"location":"api/field-type-checker/#__check_union_types","title":"__check_union_types","text":"<pre><code>@classmethod\ndef __check_union_types(cls, field_name: str, field_types: tuple[Any, ...], value: any) -&gt; None:\n    \"\"\"\n    Check if a value matches any of the types in a Union type annotation.\n\n    Args:\n        field_name: The name of the field being checked.\n        field_types: The tuple of possible types from the Union.\n        value: The value to check.\n\n    Raises:\n        TypeError: If the value doesn't match any of the types in the Union.\n    \"\"\"\n</code></pre> <p>This method checks if a value matches any of the types in a Union type annotation, providing support for Union and Optional types.</p>"},{"location":"api/field-type-checker/#convert_ellipsis_to_types","title":"convert_ellipsis_to_types","text":"<pre><code>@staticmethod\ndef convert_ellipsis_to_types(field_types: tuple[Any, ...], value: tuple) -&gt; tuple[Any, ...]:\n    \"\"\"\n    Convert a tuple type with Ellipsis (e.g., Tuple[int, ...]) to a tuple of concrete types.\n\n    This handles variable-length tuples by repeating the type before the Ellipsis.\n\n    Args:\n        field_types: The tuple of types, potentially containing an Ellipsis.\n        value: The actual tuple value being checked.\n\n    Returns:\n        A tuple of concrete types matching the length of the value.\n    \"\"\"\n</code></pre> <p>This method handles variable-length tuple types (like Tuple[int, ...]) by converting them to concrete types for validation.</p>"},{"location":"api/field-type-checker/#supported-type-validations","title":"Supported Type Validations","text":"<p>The <code>FieldTypeChecker</code> provides validation for:</p> <ol> <li> <p>Basic Types: </p> <ul> <li><code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, etc.</li> <li>Any custom type that can be checked with <code>isinstance()</code></li> </ul> </li> <li> <p>Generic Types:</p> <ul> <li><code>List[T]</code>: Lists of any type T</li> <li><code>Dict[K, V]</code>: Dictionaries with keys of type K and values of type V</li> <li><code>Set[T]</code>: Sets of any type T</li> <li><code>Tuple[T1, T2, ...]</code>: Tuples with specific element types</li> </ul> </li> <li> <p>Union Types:</p> <ul> <li><code>Union[T1, T2, ...]</code>: Values that match any of the given types</li> <li><code>Optional[T]</code> (same as <code>Union[T, None]</code>): Values of type T or None</li> </ul> </li> <li> <p>Nested Generics:</p> <ul> <li><code>List[Dict[str, Any]]</code>: Lists of dictionaries with string keys</li> <li><code>Dict[str, List[int]]</code>: Dictionaries with string keys and integer list values</li> <li>Any other valid nested generic structure</li> </ul> </li> <li> <p>Special Cases:</p> <ul> <li><code>Any</code>: Accepts any type (type checking is skipped)</li> <li><code>Tuple[T, ...]</code>: Variable-length tuples with elements of type T</li> </ul> </li> </ol>"},{"location":"api/field-type-checker/#type-checking-behavior","title":"Type Checking Behavior","text":"<p>The <code>FieldTypeChecker</code> has several important behaviors to note:</p> <ol> <li> <p>No Type Conversion: It only checks types and does not attempt to convert values between types.</p> </li> <li> <p>None Handling: None values are allowed for fields that don't have explicit None in a Union or Optional type.</p> </li> <li> <p>Instance Checking: It uses <code>isinstance()</code> for type checking, which means subclasses are accepted where their base class is expected.</p> </li> <li> <p>Union Resolution: For Union types, it tries each possible type until it finds a match or exhausts all options.</p> </li> </ol>"},{"location":"api/field-type-checker/#integration-with-configbase","title":"Integration with ConfigBase","text":"<p>The <code>FieldTypeChecker</code> is used by <code>ConfigBase</code> during configuration loading to ensure type safety:</p> <pre><code># In ConfigBase.load:\ntry:\n    FieldTypeChecker.check_types(fields, filtered_data)\nexcept TypeError as exc:\n    raise ConfigValidationError(f\"Configuration validation failed: {exc}\") from exc\n</code></pre> <p>If type validation fails, Configr raises a <code>ConfigValidationError</code> with details about the specific type mismatch.</p>"},{"location":"api/loaders/","title":"Loaders","text":"<p>The Configr library provides a flexible loading system for different configuration file formats. This page documents the loaders included with Configr and how to create custom loaders for additional file formats.</p>"},{"location":"api/loaders/#overview","title":"Overview","text":"<p>Loaders in Configr:</p> <ol> <li>Read configuration files in specific formats (JSON, YAML, etc.)</li> <li>Parse those files into Python dictionaries</li> <li>Allow the <code>ConfigBase</code> class to convert the dictionaries into typed dataclasses</li> </ol>"},{"location":"api/loaders/#base-class-configloader","title":"Base Class: ConfigLoader","text":"<p>All loaders in Configr inherit from the abstract base class <code>ConfigLoader</code>.</p> <pre><code>from abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nclass ConfigLoader(ABC):\n    \"\"\"Abstract base class for configuration loaders.\"\"\"\n\n    @abstractmethod\n    def load(self, path: Path) -&gt; Dict[str, Any]:\n        \"\"\"Load configuration from the specified path.\"\"\"\n        pass\n</code></pre>"},{"location":"api/loaders/#built-in-loaders","title":"Built-in Loaders","text":""},{"location":"api/loaders/#jsonconfigloader","title":"JSONConfigLoader","text":"<p>Loader for JSON configuration files.</p> <pre><code>class JSONConfigLoader(ConfigLoader):\n    \"\"\"Loader for JSON configuration files.\"\"\"\n\n    def load(self, path: Path) -&gt; Dict[str, Any]:\n        \"\"\"Load JSON configuration from the specified path.\"\"\"\n        with open(path, 'r') as f:\n            return json.load(f)\n</code></pre> <p>Example JSON configuration file:</p> <pre><code>{\n  \"host\": \"localhost\",\n  \"port\": 5432,\n  \"username\": \"admin\",\n  \"password\": \"secure_password\",\n  \"database\": \"my_app\"\n}\n</code></pre>"},{"location":"api/loaders/#yamlconfigloader","title":"YAMLConfigLoader","text":"<p>Loader for YAML configuration files. Requires PyYAML to be installed.</p> <pre><code>class YAMLConfigLoader(ConfigLoader):\n    \"\"\"Loader for YAML configuration files.\"\"\"\n\n    def load(self, path: Path) -&gt; Dict[str, Any]:\n        \"\"\"Load YAML configuration from the specified path.\"\"\"\n        if not YAML_AVAILABLE:\n            raise ImportError(\"PyYAML is required for YAML support. Install with 'pip install pyyaml'.\")\n\n        with open(path, 'r') as f:\n            return yaml.safe_load(f)\n</code></pre> <p>Example YAML configuration file:</p> <pre><code>host: localhost\nport: 5432\nusername: admin\npassword: secure_password\ndatabase: my_app\n</code></pre>"},{"location":"api/loaders/#creating-custom-loaders","title":"Creating Custom Loaders","text":"<p>You can extend Configr with support for additional file formats by creating custom loaders.</p>"},{"location":"api/loaders/#example-tomlconfigloader","title":"Example: TOMLConfigLoader","text":"<p>Here's an example of how to create a loader for TOML files:</p> <pre><code>from pathlib import Path\nfrom typing import Dict, Any\nfrom configr import ConfigLoader, ConfigBase\n\nclass TOMLConfigLoader(ConfigLoader):\n    \"\"\"Loader for TOML configuration files.\"\"\"\n\n    def load(self, path: Path) -&gt; Dict[str, Any]:\n        \"\"\"Load TOML configuration from the specified path.\"\"\"\n        try:\n            import toml\n        except ImportError:\n            raise ImportError(\"The 'toml' package is required for TOML support. Install with 'pip install toml'.\")\n\n        with open(path, 'r') as f:\n            return toml.load(f)\n\n# Register the loader with Configr\nConfigBase.add_loader('.toml', TOMLConfigLoader)\n</code></pre> <p>Once registered, you can use TOML files with your configuration classes:</p> <pre><code>from configr import config_class\n\n@config_class(file_name=\"database.toml\")\nclass DatabaseConfig:\n    host: str\n    port: int\n    username: str\n    password: str\n    database: str\n</code></pre> <p>Example TOML configuration file:</p> <pre><code>host = \"localhost\"\nport = 5432\nusername = \"admin\"\npassword = \"secure_password\"\ndatabase = \"my_app\"\n</code></pre>"},{"location":"api/loaders/#example-iniconfigloader","title":"Example: INIConfigLoader","text":"<p>Here's an example of a loader for INI files using Python's built-in <code>configparser</code>:</p> <pre><code>import configparser\nfrom pathlib import Path\nfrom typing import Dict, Any\nfrom configr import ConfigLoader, ConfigBase\n\nclass INIConfigLoader(ConfigLoader):\n    \"\"\"Loader for INI configuration files.\"\"\"\n\n    def load(self, path: Path) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Load INI configuration from the specified path.\"\"\"\n        config = configparser.ConfigParser(interpolation=None)\n        config.read(path)\n        return self.as_dict(config)\n\n    @staticmethod\n    def as_dict(config: configparser.ConfigParser) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Convert the parsed INI configuration to a nested dictionary.\"\"\"\n        config_dict = {}\n\n        for default_name, default_value in config.defaults().items():\n            config_dict[default_name] = default_value\n\n        for section in config.sections():\n            config_dict[section] = {\n                option: config.get(section, option) for option in config.options(section) if\n                option not in config.defaults()\n            }\n        return config_dict\n\n# Register the loader with Configr\nConfigBase.add_loader('.ini', INIConfigLoader)\n</code></pre> <p>Example INI configuration file:</p> <pre><code>[DEFAULT]\napplication = MyApp\n\n[database]\nhost = localhost\nport = 5432\nusername = admin\npassword = secure_password\ndatabase = my_app\n\n[logging]\nlevel = INFO\nfile = app.log\nformat = %(asctime)s - %(name)s - %(levelname)s - %(message)s\n</code></pre>"},{"location":"api/loaders/#managing-loaders","title":"Managing Loaders","text":""},{"location":"api/loaders/#registering-custom-loaders","title":"Registering Custom Loaders","text":"<p>Register a custom loader with <code>ConfigBase.add_loader</code>:</p> <pre><code>from configr import ConfigBase\nfrom my_loaders import CustomLoader\n\nConfigBase.add_loader('.custom', CustomLoader)\n</code></pre>"},{"location":"api/loaders/#removing-loaders","title":"Removing Loaders","text":"<p>Remove a loader with <code>ConfigBase.remove_loader</code>:</p> <pre><code>from configr import ConfigBase\n\nConfigBase.remove_loader('.yaml')\n</code></pre>"},{"location":"api/loaders/#getting-available-loaders","title":"Getting Available Loaders","text":"<p>Get all available loaders with <code>ConfigBase.get_available_loaders</code>:</p> <pre><code>from configr import ConfigBase\n\nloaders = ConfigBase.get_available_loaders()\nprint(loaders)  # {'.json': JSONConfigLoader, '.yaml': YAMLConfigLoader, ...}\n</code></pre>"},{"location":"api/loaders/#loader-selection","title":"Loader Selection","text":"<p>When loading a configuration, Configr selects the appropriate loader based on the file extension:</p> <ol> <li>If the configuration class has a <code>_config_file_name</code> with an extension (e.g., \"database.json\"), Configr uses the loader for that extension.</li> <li>If the extension is missing, Configr tries each registered loader in order until it finds a matching file.</li> <li>If no matching file is found, a <code>ConfigFileNotFoundError</code> is raised.</li> </ol>"},{"location":"api/loaders/#best-practices-for-custom-loaders","title":"Best Practices for Custom Loaders","text":"<ol> <li>Error Handling: Include clear error messages for missing dependencies or file format issues.</li> <li>Dependencies: Document any external dependencies required by your loader.</li> <li>Type Conversion: Ensure your loader returns data as expected by Configr (dictionaries with the correct types).</li> <li>File Extension: Use a unique file extension for your format to avoid conflicts.</li> </ol>"},{"location":"api/loaders/#example-usage","title":"Example Usage","text":"<pre><code>from configr import config_class, ConfigBase\nfrom my_loaders import XML_ConfigLoader\n\n# Register custom XML loader\nConfigBase.add_loader('.xml', XML_ConfigLoader)\n\n@config_class(file_name=\"database.xml\")\nclass DatabaseConfig:\n    host: str\n    port: int\n    username: str\n    password: str\n    database: str\n\n# Load from XML file\ndb_config = ConfigBase.load(DatabaseConfig)\n</code></pre>"},{"location":"api/utils/","title":"Utilities","text":"<p>Configr includes utility functions that support the configuration management functionality. This page documents the core utility functions available in Configr.</p>"},{"location":"api/utils/#to_snake_case","title":"to_snake_case","text":"<pre><code>def to_snake_case(name: str) -&gt; str:\n    \"\"\"\n    Convert name to snake case, special chars are replaced with _\n    and numbers are kept.\n    \"\"\"\n</code></pre> <p>The <code>to_snake_case</code> function converts a string in camelCase, PascalCase, or other formats to snake_case.</p>"},{"location":"api/utils/#parameters","title":"Parameters","text":"Parameter Type Description <code>name</code> <code>str</code> The string to convert to snake_case format"},{"location":"api/utils/#returns","title":"Returns","text":"<p>A string converted to snake_case format.</p>"},{"location":"api/utils/#examples","title":"Examples","text":"<pre><code>from configr.utils import to_snake_case\n\n# Converting PascalCase\nresult = to_snake_case(\"DatabaseConfig\")\nprint(result)  # \"database_config\"\n\n# Converting camelCase\nresult = to_snake_case(\"databaseConfig\")\nprint(result)  # \"database_config\"\n\n# With numbers\nresult = to_snake_case(\"API123Config\")\nprint(result)  # \"api123_config\"\n\n# With acronyms\nresult = to_snake_case(\"DBConfig\")\nprint(result)  # \"db_config\"\n\n# With mixed case\nresult = to_snake_case(\"JSONAPIConfig\")\nprint(result)  # \"json_api_config\"\n</code></pre>"},{"location":"api/utils/#implementation-details","title":"Implementation Details","text":"<p>The function:</p> <ol> <li>If the input is a simple lowercase word without special characters, returns it as is</li> <li>Otherwise, uses regular expressions to find:<ul> <li>Lowercase letters and numbers together</li> <li>Uppercase letters, optionally followed by uppercase letters, numbers, or lowercase letters</li> </ul> </li> <li>Joins these elements with underscores</li> <li>Converts everything to lowercase</li> </ol> <p>The core regular expression pattern is: <pre><code>re.findall(r'[a-z0-9]+|[A-Z](?:[A-Z0-9]*(?![a-z])|[a-z0-9]*)', name)\n</code></pre></p> <p>This pattern matches:</p> <ul> <li>Groups of lowercase letters and numbers: <code>[a-z0-9]+</code></li> </ul> <p>OR</p> <ul> <li> <p>An uppercase letter: <code>[A-Z]</code> followed by either:</p> <ul> <li>Zero or more uppercase letters and numbers not followed by a lowercase letter: <code>[A-Z0-9]*(?![a-z])</code></li> </ul> <p>OR</p> <ul> <li>Zero or more lowercase letters and numbers: <code>[a-z0-9]*</code></li> </ul> </li> </ul>"},{"location":"api/utils/#usage-in-configr","title":"Usage in Configr","text":"<p>The <code>to_snake_case</code> function is used internally by Configr in the <code>config_class</code> decorator to derive default configuration file names from class names when a specific file name is not provided.</p> <p>For example, a class named <code>DatabaseConfig</code> would, by default, look for a configuration file named <code>database_config.json</code> (or other supported extensions).</p> <pre><code>@config_class  # Will use database_config.json by default\nclass DatabaseConfig:\n    host: str\n    port: int\n</code></pre> <p>This helps maintain a consistent naming convention for configuration files that follows Python's standard style guidelines.</p>"},{"location":"user-guide/","title":"User Guide Overview","text":"<p>Welcome to the Configr User Guide. This guide provides comprehensive information about using the Configr library effectively in your projects.</p>"},{"location":"user-guide/#key-concepts","title":"Key Concepts","text":"<p>Configr is built around a few core concepts:</p>"},{"location":"user-guide/#configuration-classes","title":"Configuration Classes","text":"<p>Configuration classes define the structure of your configuration using Python dataclasses. They specify what configuration values are available, their types, and default values.</p>"},{"location":"user-guide/#configuration-loading","title":"Configuration Loading","text":"<p>Configr provides mechanisms to load configuration data from files and convert it to your configuration classes, ensuring type safety and validation.</p>"},{"location":"user-guide/#file-formats","title":"File Formats","text":"<p>The library supports multiple file formats, including JSON and YAML, and can be extended to support additional formats through custom loaders.</p>"},{"location":"user-guide/#structure","title":"Structure","text":"<p>This user guide is organized into the following sections:</p> <ul> <li>Basic Usage: Step-by-step guide to using Configr in common scenarios</li> <li>Configuration Classes: Details about defining and working with configuration classes</li> <li>Custom Loaders: Information about extending Configr with support for additional file formats</li> </ul>"},{"location":"user-guide/#common-patterns","title":"Common Patterns","text":"<p>Here are some common patterns and best practices when using Configr:</p>"},{"location":"user-guide/#centralized-configuration","title":"Centralized Configuration","text":"<p>Create a central module for all your configuration classes:</p> <pre><code># config.py\nfrom configr import config_class, ConfigBase\n\n@config_class\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n\n@config_class\nclass RedisConfig:\n    host: str = \"localhost\"\n    port: int = 6379\n    db: int = 0\n\n# Load all configurations at once\ndef load_all():\n    return {\n        \"db\": ConfigBase.load(DatabaseConfig),\n        \"redis\": ConfigBase.load(RedisConfig)\n    }\n</code></pre>"},{"location":"user-guide/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Use different files for different environments:</p> <pre><code>import os\n\n@config_class(file_name=f\"database.{os.environ.get('ENV', 'dev')}.json\")\nclass DatabaseConfig:\n    host: str\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n</code></pre>"},{"location":"user-guide/#configuration-validation","title":"Configuration Validation","text":"<p>Add validation logic to your configuration classes:</p> <pre><code>from configr import config_class, ConfigValidationError\n\n@config_class\nclass ServerConfig:\n    host: str\n    port: int\n    workers: int\n\n    def __post_init__(self):\n        if self.port &lt; 1024 or self.port &gt; 65535:\n            raise ConfigValidationError(f\"Invalid port: {self.port}\")\n        if self.workers &lt; 1:\n            raise ConfigValidationError(f\"Workers must be at least 1, got {self.workers}\")\n</code></pre>"},{"location":"user-guide/#next-steps","title":"Next Steps","text":"<p>Continue to the Basic Usage section to learn how to use Configr in your projects.</p>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>This guide walks through the common usage patterns for Configr in your Python applications.</p>"},{"location":"user-guide/basic-usage/#project-setup","title":"Project Setup","text":"<p>Let's begin with a simple project structure:</p> <pre><code>my_project/\n\u251c\u2500\u2500 _config/\n\u2502   \u251c\u2500\u2500 database.json\n\u2502   \u2514\u2500\u2500 app_settings.yaml\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"user-guide/basic-usage/#configuration-files","title":"Configuration Files","text":"<p>Here are examples of configuration files:</p>"},{"location":"user-guide/basic-usage/#_configdatabasejson","title":"<code>_config/database.json</code>","text":"<pre><code>{\n  \"host\": \"localhost\",\n  \"port\": 5432,\n  \"username\": \"admin\",\n  \"password\": \"secure_password\",\n  \"database\": \"my_app\"\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#_configapp_settingsyaml","title":"<code>_config/app_settings.yaml</code>","text":"<pre><code>debug: true\nlog_level: DEBUG\nmax_connections: 50\ntimeout: 30\nenable_caching: true\nenable_metrics: false\n</code></pre>"},{"location":"user-guide/basic-usage/#defining-configuration-classes","title":"Defining Configuration Classes","text":"<p>First, define your configuration classes that match your configuration files:</p> <pre><code># config.py\nfrom configr import config_class\n\n@config_class(file_name=\"database.json\")\nclass DatabaseConfig:\n    host: str\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n\n@config_class(file_name=\"app_settings.yaml\")\nclass AppSettings:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    max_connections: int = 100\n    timeout: int = 60\n    enabled_cachine: bool = false\n    enable_metrics: bool = false\n</code></pre>"},{"location":"user-guide/basic-usage/#loading-configuration","title":"Loading Configuration","text":"<p>Next, load the configuration in your application:</p> <pre><code># app.py\nfrom configr import ConfigBase\nfrom config import DatabaseConfig, AppSettings\n\n# Load configurations\ndb_config = ConfigBase.load(DatabaseConfig)\napp_settings = ConfigBase.load(AppSettings)\n\n# Use configurations\nif app_settings.debug:\n    print(f\"Running in DEBUG mode with log level {app_settings.log_level}\")\n    print(f\"Caching enabled: {app_settings.features['enable_caching']}\")\n\n# Database connection example\nprint(f\"Connecting to database {db_config.database} at {db_config.host}:{db_config.port}\")\nprint(f\"Using credentials: {db_config.username}:{'*' * len(db_config.password)}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":"<p>Here's how to handle common errors:</p> <pre><code>from configr import ConfigBase, ConfigFileNotFoundError, ConfigValidationError\n\ntry:\n    config = ConfigBase.load(DatabaseConfig)\nexcept ConfigFileNotFoundError as e:\n    print(f\"Configuration file not found: {e}\")\n    print(\"Using default configuration...\")\n    config = DatabaseConfig(\n        host=\"localhost\",\n        username=\"default\",\n        password=\"default\",\n        database=\"default_db\"\n    )\nexcept ConfigValidationError as e:\n    print(f\"Configuration validation failed: {e}\")\n    raise  # Re-raise if validation is critical\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n    raise\n</code></pre>"},{"location":"user-guide/basic-usage/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>For different environments (development, testing, production), you can:</p> <ol> <li> <p>Use environment variables to select configuration files:</p> <pre><code>import os\n\nENV = os.environ.get(\"ENV\", \"development\")\n\n@config_class(file_name=f\"database.{ENV}.json\")\nclass DatabaseConfig:\n    # ...\n</code></pre> </li> <li> <p>Override values with environment variables:</p> <pre><code>import os\nfrom configr import ConfigBase\n\ndb_config = ConfigBase.load(DatabaseConfig)\n\n# Override with environment variables if present\nif \"DB_HOST\" in os.environ:\n    db_config.host = os.environ[\"DB_HOST\"]\nif \"DB_PORT\" in os.environ:\n    db_config.port = int(os.environ[\"DB_PORT\"])\n</code></pre> </li> </ol>"},{"location":"user-guide/basic-usage/#working-with-nested-configurations","title":"Working with Nested Configurations","text":"<p>Configr automatically handles nested dataclass structures in your configuration hierarchy. This allows you to organize complex configuration in a type-safe and well-structured manner.</p>"},{"location":"user-guide/basic-usage/#defining-nested-configuration-classes","title":"Defining Nested Configuration Classes","text":"<pre><code>from configr import config_class\nfrom dataclasses import dataclass\n\n@dataclass\nclass LoggingConfig:\n    level: str = \"INFO\"\n    format: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    file: str = None\n\n@dataclass\nclass Tag:\n   name: str = None\n   category: str = None\n\n@config_class(file_name=\"app_config.json\")\nclass AppConfig:\n    name: str\n    version: str\n    debug: bool = False\n    logging: LoggingConfig = None\n    tags: list[Tags] = None\n</code></pre>"},{"location":"user-guide/basic-usage/#configuration-file-structure","title":"Configuration File Structure","text":"<p>The corresponding JSON file structure would look like:</p> <pre><code>{\n  \"name\": \"MyApp\",\n  \"version\": \"1.0.0\",\n  \"debug\": true,\n  \"logging\": {\n    \"level\": \"DEBUG\",\n    \"file\": \"app.log\"\n  },\n  \"tags\": [\n    {\"name\":  \"MyApp\", \"category\":  \"application\"},\n    {\"name\":  \"1.0.0\", \"category\":  \"version\"}\n  ]\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#automatic-conversion","title":"Automatic Conversion","text":"<p>Configr will automatically:</p> <ol> <li>Detect that <code>logging</code> is a field typed as <code>LoggingConfig</code> dataclass</li> <li>Convert the nested JSON object to a <code>LoggingConfig</code> instance</li> <li>Detect that 'tags' is a field with a list of type <code>Tag</code> dataclass</li> <li>Convert each list element JSON object to a <code>Tag</code> instance</li> <li>Perform this conversion recursively for any level of nesting</li> </ol>"},{"location":"user-guide/basic-usage/#accessing-nested-configuration","title":"Accessing Nested Configuration","text":"<p>You can access the nested configuration with native dot notation:</p> <pre><code>config = ConfigBase.load(AppConfig)\n\n# Access nested configuration using dot notation\nlog_level = config.logging.level\nlog_file = config.logging.file\ntag1 = config.tags[0].name\n\nprint(f\"Logging to {log_file} with level {log_level}\")\n\nfor tag in config.tags:\n    print(f\"Tag: {tag.name=}, {tag.category=}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#default-values-in-nested-classes","title":"Default Values in Nested Classes","text":"<p>You can provide default values at any level of the configuration hierarchy:</p> <pre><code>@dataclass\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str = None\n    password: str = None\n\n@dataclass\nclass CacheConfig:\n    enabled: bool = False\n    ttl: int = 300\n\n@config_class(file_name=\"server_config.json\")\nclass ServerConfig:\n    host: str = \"0.0.0.0\"\n    port: int = 8080\n    database: DatabaseConfig = None\n    cache: CacheConfig = None\n</code></pre> <p>With this approach, if the configuration file doesn't specify certain nested objects, they'll be created with their default values.</p>"},{"location":"user-guide/basic-usage/#configuration-directory","title":"Configuration Directory","text":"<p>By default, Configr looks for configuration files in the <code>_config/</code> directory. You can customize this:</p> <pre><code>from configr import ConfigBase\nfrom pathlib import Path\n\n# Set configuration directory\nConfigBase.set_config_dir(\"path/to/config\")\n# Or using a Path object\nConfigBase.set_config_dir(Path(\"path/to/config\"))\n\n# Then load configuration\nconfig = ConfigBase.load(AppConfig)\n</code></pre>"},{"location":"user-guide/basic-usage/#putting-it-all-together","title":"Putting It All Together","text":"<p>Here's a complete example integrating the concepts above:</p> <pre><code># config.py\nimport os\nfrom configr import config_class, ConfigBase, ConfigFileNotFoundError\nfrom dataclasses import dataclass\n\n# Get environment\nENV = os.environ.get(\"ENV\", \"development\")\n\n@dataclass\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str = None\n    password: str = None\n    database: str = None\n\n@dataclass\nclass LoggingConfig:\n    level: str = \"INFO\"\n    file: str = None\n\n@config_class(file_name=f\"app.{ENV}.json\")\nclass AppConfig:\n    name: str = \"MyApp\"\n    version: str = \"1.0.0\"\n    debug: bool = False\n    database: DatabaseConfig = None\n    logging: LoggingConfig = None\n\n    def __post_init__(self):\n        # Apply environment variable overrides\n        if \"LOG_LEVEL\" in os.environ:\n            self.logging.level = os.environ[\"LOG_LEVEL\"]\n</code></pre>"},{"location":"user-guide/basic-usage/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics of using Configr, you might want to explore:</p> <ul> <li>Configuration Classes for more details on defining configuration structures</li> <li>Custom Loaders to learn how to extend Configr with support for additional file formats</li> </ul>"},{"location":"user-guide/config-classes/","title":"Configuration Classes","text":"<p>Configuration classes are at the heart of Configr. They define the structure of your configuration using Python's dataclasses and type hints, providing a type-safe approach to configuration management.</p>"},{"location":"user-guide/config-classes/#basic-configuration-class","title":"Basic Configuration Class","text":"<p>At its simplest, a configuration class is just a dataclass decorated with <code>@config_class</code>:</p> <pre><code>from configr import config_class\n\n@config_class\nclass DatabaseConfig:\n    host: str = 'localhost'\n    port: int = 5432\n    username: str\n    password: str\n    database: str\n</code></pre> <p>This class defines a configuration with five fields:</p> <ul> <li><code>host</code>: A string with a default value of localhost (optional)</li> <li><code>port</code>: An integer with a default value of 5432 (optional)</li> <li><code>username</code>: A string with no default value (required)</li> <li><code>password</code>: A string with no default value (required)</li> <li><code>database</code>: A string with no default value (required)</li> </ul>"},{"location":"user-guide/config-classes/#the-config_class-decorator","title":"The <code>@config_class</code> Decorator","text":"<p>The <code>@config_class</code> decorator does several things:</p> <ol> <li>It ensures the class is a dataclass (converts it if it's not already)</li> <li>It adds a <code>_config_file_name</code> attribute to specify which file to load</li> <li>It ensures the file has a supported extension (.json by default)</li> </ol>"},{"location":"user-guide/config-classes/#specifying-a-custom-file-name","title":"Specifying a Custom File Name","text":"<p>By default, Configr will look for a file named after the class in snake_case with a <code>.json</code> extension. For example, <code>DatabaseConfig</code> will look for <code>_config/database_config.json</code>. If the file does not exist, it will look for each of the registered extensions, e.g. <code>_config/database_config.yaml</code> or <code>_config/database_config.yml</code> </p> <p>You can specify a custom file name:</p> <pre><code>@config_class(file_name=\"db_settings.yaml\")\nclass DatabaseConfig:\n    host: str = 'localhost'\n    port: int = 5432\n    # ...\n</code></pre> <p>Now Configr will look for <code>_config/db_settings.yaml</code>.</p>"},{"location":"user-guide/config-classes/#using-with-existing-dataclasses","title":"Using with Existing Dataclasses","text":"<p>If your class is already a dataclass, the decorator will preserve that:</p> <pre><code>from dataclasses import dataclass\nfrom configr import config_class\n\n@config_class  # This works\n@dataclass\nclass AppConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n\n# Or this way:\n@dataclass\n@config_class  # This also works\nclass ServerConfig:\n    host: str = 'localhost'\n    port: int = 8080\n</code></pre>"},{"location":"user-guide/config-classes/#type-safety-and-validation","title":"Type Safety and Validation","text":"<p>Configr leverages Python's type hints to provide type safety for your configuration.</p>"},{"location":"user-guide/config-classes/#basic-types","title":"Basic Types","text":"<p>You can use all standard Python types:</p> <pre><code>@config_class\nclass AppConfig:\n    name: str\n    version: str\n    port: int\n    debug: bool\n    rate_limit: float\n    tags: list \n    options: dict\n    handler: callable = None\n</code></pre>"},{"location":"user-guide/config-classes/#type-validation","title":"Type Validation","text":"<p>Configr doesn't perform automatic type conversion or validation when loading configuration. Instead, it relies on Python's dataclass mechanism to handle type checking:</p> <pre><code># _config/app_config.json\n{\n  \"name\": \"MyApp\",\n  \"version\": \"1.0.0\",\n  \"port\": \"8080\",  # This is a string, not an int!\n  \"debug\": true,\n  \"rate_limit\": 100.0,\n  \"tags\": [\"tag1\", \"tag2\"],\n  \"options\": {}\n}\n\n# This will raise a ConfigValidationError when instantiating the dataclass\nconfig = ConfigBase.load(AppConfig)\n</code></pre> <p>To add custom validation, use the <code>__post_init__</code> method in your config class:</p> <pre><code>from configr import config_class, ConfigValidationError\n\n@config_class\nclass ServerConfig:\n    host: str\n    port: int\n\n    def __post_init__(self):\n        if self.port &lt; 1024 or self.port &gt; 65535:\n            raise ConfigValidationError(f\"Invalid port: {self.port}\")\n</code></pre>"},{"location":"user-guide/config-classes/#default-values","title":"Default Values","text":"<p>Specify default values for optional configuration parameters:</p> <pre><code>@config_class\nclass AppConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n    max_connections: int = 100\n    timeout: int = 30\n</code></pre> <p>Fields without default values are considered required and must be provided in the configuration file.</p>"},{"location":"user-guide/config-classes/#inheritance","title":"Inheritance","text":"<p>You can use inheritance to create specialized configuration classes:</p> <pre><code>@config_class\nclass BaseConfig:\n    debug: bool = False\n    log_level: str = \"INFO\"\n\n@config_class\nclass DevelopmentConfig(BaseConfig):\n    debug: bool = True\n    database_url: str = \"sqlite:///dev.db\"\n\n@config_class\nclass ProductionConfig(BaseConfig):\n    log_level: str = \"WARNING\"\n    database_url: str = \"postgresql://user:pass@localhost/prod\"\n</code></pre>"},{"location":"user-guide/config-classes/#configuration-class-methods","title":"Configuration Class Methods","text":"<p>You can add methods to your configuration classes for convenience:</p> <pre><code>@config_class\nclass DatabaseConfig:\n    driver: str\n    host: str\n    port: int\n    username: str\n    password: str\n    database: str\n\n    def get_connection_string(self):\n        \"\"\"Generate a database connection string.\"\"\"\n        return f\"{self.driver}://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}\"\n\n    def get_connection_params(self):\n        \"\"\"Return connection parameters as a dictionary.\"\"\"\n        return {\n            \"driver\": self.driver,\n            \"host\": self.host,\n            \"port\": self.port,\n            \"username\": self.username,\n            \"password\": self.password,\n            \"database\": self.database\n        }\n</code></pre>"},{"location":"user-guide/config-classes/#nested-configuration","title":"Nested Configuration","text":"<p>Configr provides robust support for nested configuration structures, allowing you to organize complex configurations in a clean, type-safe manner. The library automatically handles the conversion between nested JSON/YAML structures and Python dataclasses.</p>"},{"location":"user-guide/config-classes/#using-nested-dataclasses","title":"Using Nested Dataclasses","text":"<p>You can define nested configuration structures by using dataclasses as field types within your config classes:</p> <pre><code>from configr import config_class\nfrom dataclasses import dataclass\n\n# Define nested dataclass for database configuration\n@dataclass\nclass DatabaseConfig:\n    host: str = \"localhost\"\n    port: int = 5432\n    username: str = None\n    password: str = None\n    database: str = None\n\n# Define nested dataclass for logging configuration\n@dataclass\nclass LoggingConfig:\n    level: str = \"INFO\"\n    file: str = None\n    format: str = \"%(asctime)s - %(levelname)s - %(message)s\"\n\n# Main configuration class using nested dataclasses\n@config_class(file_name=\"app_config.json\")\nclass AppConfig:\n    name: str\n    version: str\n    debug: bool = False\n    database: DatabaseConfig = None  # Nested dataclass field\n    logging: LoggingConfig = None    # Nested dataclass field\n</code></pre> <p>With a corresponding JSON file like:</p> <pre><code>{\n  \"name\": \"MyApp\",\n  \"version\": \"1.0.0\",\n  \"debug\": true,\n  \"database\": {\n    \"host\": \"db.example.com\",\n    \"port\": 5432,\n    \"username\": \"admin\",\n    \"password\": \"secure_password\",\n    \"database\": \"myapp_db\"\n  },\n  \"logging\": {\n    \"level\": \"DEBUG\",\n    \"file\": \"app.log\"\n  }\n}\n</code></pre> <p>When you load the configuration, Configr will automatically:</p> <ol> <li>Recognize that <code>database</code> is a field of type <code>DatabaseConfig</code></li> <li>Convert the nested JSON object to a <code>DatabaseConfig</code> instance</li> <li>Similarly convert the <code>logging</code> field to a <code>LoggingConfig</code> instance</li> <li>Handle any level of nesting recursively</li> </ol> <p>Accessing nested configuration is done with standard dot notation:</p> <pre><code>from configr import ConfigBase\n\n# Load the configuration\nconfig = ConfigBase.load(AppConfig)\n\n# Access nested fields with dot notation\ndb_host = config.database.host        # \"db.example.com\"\nlog_level = config.logging.level      # \"DEBUG\"\nlog_format = config.logging.format    # Uses default value\n</code></pre>"},{"location":"user-guide/config-classes/#collections-of-dataclasses","title":"Collections of Dataclasses","text":"<p>Configr also supports collections of dataclasses, such as lists or dictionaries of dataclass instances. This is useful for configuration items that can have multiple instances or variations.</p>"},{"location":"user-guide/config-classes/#lists-of-dataclasses","title":"Lists of Dataclasses","text":"<pre><code>from configr import config_class\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass ServiceConfig:\n    name: str\n    url: str\n    timeout: int = 30\n    retries: int = 3\n\n@config_class(file_name=\"services_config.json\")\nclass ServicesConfig:\n    enabled: bool = True\n    services: List[ServiceConfig] = None  # List of dataclass instances\n</code></pre> <p>With a JSON file like:</p> <pre><code>{\n  \"enabled\": true,\n  \"services\": [\n    {\n      \"name\": \"authentication\",\n      \"url\": \"https://auth.example.com/api\",\n      \"timeout\": 10\n    },\n    {\n      \"name\": \"storage\",\n      \"url\": \"https://storage.example.com/api\",\n      \"timeout\": 60,\n      \"retries\": 5\n    }\n  ]\n}\n</code></pre> <p>Configr will automatically convert each object in the <code>services</code> list to a <code>ServiceConfig</code> instance:</p> <pre><code>config = ConfigBase.load(ServicesConfig)\n\n# Access the first service\nauth_service = config.services[0]\nprint(auth_service.name)     # \"authentication\"\nprint(auth_service.timeout)  # 10\nprint(auth_service.retries)  # 3 (default value)\n\n# Iterate through all services\nfor service in config.services:\n    print(f\"{service.name}: {service.url}\")\n</code></pre>"},{"location":"user-guide/config-classes/#default-values-and-none-handling","title":"Default Values and None Handling","text":"<p>Configr intelligently handles default values in nested dataclasses:</p> <ol> <li>If a nested dataclass field is <code>None</code> in the configuration file, Configr will attempt to create an empty instance using the class's default constructor.</li> <li>If the nested dataclass constructor requires arguments with no defaults, the field will remain <code>None</code>.</li> <li>Default values in nested dataclasses are respected at all levels of nesting.</li> </ol> <p>Example:</p> <pre><code>@dataclass\nclass DatabaseConfig:\n    # These fields have no defaults and are required\n    username: str\n    password: str\n    database: str\n    host: str = \"localhost\"\n    port: int = 5432\n\n@config_class\nclass AppConfig:\n    debug: bool = False\n    # This will be None if not in the config file, since DatabaseConfig\n    # has required fields with no defaults\n    database: DatabaseConfig = None\n</code></pre>"},{"location":"user-guide/config-classes/#type-validation-in-nested-structures","title":"Type Validation in Nested Structures","text":"<p>Configr performs type validation for nested dataclass fields just like it does for top-level fields. If the data in your configuration file doesn't match the expected types in your nested dataclasses, Configr will raise a <code>ConfigValidationError</code>.</p> <p>This ensures that your entire configuration hierarchy maintains type safety.</p>"},{"location":"user-guide/config-classes/#customizing-nested-configuration","title":"Customizing Nested Configuration","text":"<p>You can add methods to your nested dataclasses for additional functionality:</p> <pre><code>@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    username: str\n    password: str\n    database: str\n\n    def get_connection_string(self):\n        \"\"\"Generate a database connection string.\"\"\"\n        return f\"postgresql://{self.username}:{self.password}@{self.host}:{self.port}/{self.database}\"\n\n    def __post_init__(self):\n        \"\"\"Validate database configuration.\"\"\"\n        if self.port &lt; 1024 or self.port &gt; 65535:\n            raise ValueError(f\"Invalid port: {self.port}\")\n</code></pre> <p>Then use these methods in your code:</p> <pre><code>config = ConfigBase.load(AppConfig)\nconnection_str = config.database.get_connection_string()\n</code></pre>"},{"location":"user-guide/config-classes/#best-practices-for-nested-configuration","title":"Best Practices for Nested Configuration","text":"<ol> <li> <p>Keep nesting reasonable: While Configr supports arbitrary nesting, keep your hierarchy sensible for maintainability.</p> </li> <li> <p>Use explicit types: Always use explicit type annotations, especially for collections of dataclasses.</p> </li> <li> <p>Provide defaults where appropriate: Use default values for optional fields to make your configuration more robust.</p> </li> <li> <p>Add validation in <code>__post_init__</code>: Add custom validation in the <code>__post_init__</code> method of your dataclasses.</p> </li> <li> <p>Break complex configurations into logical modules: For very complex configurations, consider splitting your config classes across multiple modules.</p> </li> </ol>"},{"location":"user-guide/config-classes/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>For environment-specific configuration:</p> <pre><code>import os\n\nENV = os.environ.get(\"ENV\", \"development\")\n\n@config_class(file_name=f\"app.{ENV}.json\")\nclass AppConfig:\n    debug: bool = ENV != \"production\"\n    log_level: str = \"DEBUG\" if ENV != \"production\" else \"INFO\"\n    # ...\n</code></pre>"},{"location":"user-guide/config-classes/#best-practices","title":"Best Practices","text":"<p>When working with configuration classes:</p> <ol> <li> <p>Use Meaningful Default Values: Provide sensible defaults whenever possible</p> </li> <li> <p>Add Validation Logic: Use <code>__post_init__</code> to validate configuration beyond the type checking offered by Configr</p> </li> <li> <p>Organize Related Settings: Group related settings in separate classes</p> </li> <li> <p>Use Strong Typing: Leverage Python's type hints for better code quality</p> </li> <li> <p>Manage Secrets Carefully: Consider separating sensitive information from regular configuration</p> </li> </ol>"},{"location":"user-guide/config-classes/#next-steps","title":"Next Steps","text":"<p>Now that you understand how to work with configuration classes in Configr, you might want to explore:</p> <ul> <li>Custom Loaders to learn how to extend Configr with support for additional file formats</li> </ul>"},{"location":"user-guide/custom-loaders/","title":"Custom Loaders","text":"<p>Configr comes with built-in support for JSON and YAML configuration files, but you can extend it to support additional file formats by creating custom loaders.</p>"},{"location":"user-guide/custom-loaders/#built-in-loaders","title":"Built-in Loaders","text":"<p>Configr includes the following loaders by default:</p> <ul> <li><code>JSONConfigLoader</code>: For <code>.json</code> files</li> <li><code>YAMLConfigLoader</code>: For <code>.yaml</code> and <code>.yml</code> files (requires PyYAML)</li> </ul> <p>These loaders are registered in the <code>ConfigBase._loaders</code> dictionary:</p> <pre><code>_loaders: ClassVar[dict[str, Type[ConfigLoader]]] = {\n    '.json': JSONConfigLoader,\n    '.yaml': YAMLConfigLoader,\n    '.yml': YAMLConfigLoader\n}\n</code></pre>"},{"location":"user-guide/custom-loaders/#creating-a-custom-loader","title":"Creating a Custom Loader","text":"<p>To create a custom loader, you need to:</p> <ol> <li>Create a subclass of <code>ConfigLoader</code></li> <li>Implement the <code>load</code> method</li> <li>Register the loader with <code>ConfigBase.add_loader</code> method</li> </ol>"},{"location":"user-guide/custom-loaders/#step-1-create-a-configloader-subclass","title":"Step 1: Create a ConfigLoader Subclass","text":"<p>Create a class that inherits from <code>ConfigLoader</code> and implements the <code>load</code> method:</p> <pre><code>from pathlib import Path\nfrom typing import Dict, Any\nfrom configr import ConfigLoader\n\nclass TOMLConfigLoader(ConfigLoader):\n    \"\"\"Loader for TOML configuration files.\"\"\"\n\n    def load(self, path: Path) -&gt; Dict[str, Any]:\n        \"\"\"Load TOML configuration from the specified path.\"\"\"\n        try:\n            import toml\n        except ImportError:\n            raise ImportError(\"The 'toml' package is required for TOML support. Install with 'pip install toml'.\")\n\n        with open(path, 'r') as f:\n            return toml.load(f)\n</code></pre>"},{"location":"user-guide/custom-loaders/#step-2-register-the-loader","title":"Step 2: Register the Loader","text":"<p>Register your loader with <code>ConfigBase.add_loader</code>:</p> <pre><code>from configr import ConfigBase\n\n# Register the TOML loader\nConfigBase.add_loader('.toml', TomlConfigLoader)\n</code></pre>"},{"location":"user-guide/custom-loaders/#step-3-use-your-custom-loader","title":"Step 3: Use Your Custom Loader","text":"<p>Now you can use TOML files for your configuration:</p> <pre><code>from configr import config_class, ConfigBase\n\n@config_class(file_name=\"database.toml\")\nclass DatabaseConfig:\n    host: str = 'localhost'\n    port: str = '5432'\n    username: str = None\n    password: str = None\n    database: str = None\n\n# This will use the TOMLConfigLoader to load database.toml\ndb_config = ConfigBase.load(DatabaseConfig)\n</code></pre>"},{"location":"user-guide/custom-loaders/#example-ini-configuration-loader","title":"Example: INI Configuration Loader","text":"<p>Here's an example of a loader for INI files using Python's <code>configparser</code>:</p> <pre><code>import configparser\nfrom pathlib import Path\n\nfrom configr import ConfigLoader\n\n\nclass INIConfigLoader(ConfigLoader):\n    \"\"\"Loader for INI configuration files.\"\"\"\n\n    def load(self, path: Path) -&gt; dict[str, dict[str, any]]:\n        config = configparser.ConfigParser(interpolation=None)\n        config.read(path)\n        return self.as_dict(config)\n\n    @staticmethod\n    def as_dict(config: configparser.ConfigParser):\n        \"\"\"\n        Convert the parsed INI configuration to a nested dictionary.\n\n        This method transforms the ConfigParser representation into a dictionary structure\n        where each section becomes a top-level key containing a dictionary of its options.\n        Default values are included at the top level of the resulting dictionary.\n\n        Returns:\n            dict[str, dict[str, any]]: A nested dictionary representation of the configuration.\n                The outer dictionary keys are section names, and the inner dictionaries\n                contain option name-value pairs for each section. Default values are included\n                directly in the outer dictionary.\n        \"\"\"\n        config_dict = {}\n\n        for default_name, default_value in config.defaults().items():\n            config_dict[default_name] = default_value\n\n        for section in config.sections():\n            config_dict[section] = {\n                option: config.get(section, option) for option in config.options(section) if\n                option not in config.defaults()\n            }\n        return config_dict\n</code></pre> <p>Then register it:</p> <pre><code>ConfigBase.add_loader('.ini', INIConfigLoader)\n</code></pre> <p>And use it:</p> <pre><code>@dataclass\nclass DatabaseConfig:\n    host: str = 'localhost'\n    port: str = '5432'\n    username: str = None\n    password: str = None\n    database: str = None\n\n\n@dataclass\nclass LoggingConfig:\n    level: str\n    file: str\n    format: str\n\n\n@config_class(file_name=\"app_config.ini\")\nclass AppConfig:\n    application: str\n    database: DatabaseConfig\n    logging: LoggingConfig\n\nappConfig = ConfigBase.load(AppConfig)\n</code></pre> <p>Example INI file:</p> <pre><code>[DEFAULT]\napplication = MyApp\n\n[database]\nhost = localhost\nport = 5432\nusername = admin\npassword = secret\ndatabase = my_app\n\n[logging]\nlevel = INFO\nfile = app.log\nformat = %(asctime)s - %(name)s - %(levelname)s - %(message)s\n</code></pre>"}]}